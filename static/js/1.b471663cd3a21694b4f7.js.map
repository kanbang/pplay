{"version":3,"sources":["webpack:///./node_modules/glsl-parser/parser.js"],"names":["__extends","derived","base","prototype","Object","create","constructor","__imul","Math","imul","a","b","assert","truth","Error","GLSLX","RenameSymbols","ALL","CompilerOptions","this","compactSyntaxTree","removeWhitespace","renameSymbols","trimSymbols","fileAccess","globals","ExtensionBehavior","DEFAULT","DISABLE","ENABLE","REQUIRE","WARN","CompilerData","currentExtensions","_nextSymbolID","nextSymbolID","extensionBehavior","name","in_StringMap","get","Compiler","typeCheck","log","sources","options","hasErrors","unshift","Source","API","i","list","count","length","source","in_List","tokens","Tokenizer","tokenize","global","Node","NodeKind","GLOBAL","scope","Scope","ScopeKind","data","resolver","Resolver","i1","list1","count1","source1","Parser","parse","resolveGlobal","ControlFlowAnalyzer","_isLoopBreakTarget","_isControlFlowLive","pushBlock","node","parent","push","last","in_NodeKind","isLoop","kind","popBlock","takeLast","hasControlFlowAtEnd","WHILE","whileTest","isTrue","DO_WHILE","doWhileTest","FOR","forTest","setLast","visitStatement","BREAK","RETURN","DISCARD","CONTINUE","IF","test","ifTest","trueValue","ifTrue","falseValue","ifFalse","isFalse","Folder","fold","RELEASE","_fold","folded","UNKNOWN_CONSTANT","_check","INT","resolvedType","Type","hasChildren","BOOL","FLOAT","CALL","target","callTarget","TYPE","componentType","componentCount","childCount","child","nextSibling","struct","symbol","asStruct","variables","child1","type","ERROR","clone","NAME","_foldName","SEQUENCE","_foldSequence","HOOK","_foldHook","DOT","_foldDot","INDEX","_foldIndex","_foldCall","NEGATIVE","_foldUnaryFloatOrInt","x","NOT","_foldUnaryBool","POSITIVE","ADD","_foldBinaryFloatOrInt","SUBTRACT","MULTIPLY","_foldMultiply","DIVIDE","EQUAL","NOT_EQUAL","_foldBinaryEquality","LOGICAL_AND","_foldBinaryBool","LOGICAL_OR","LOGICAL_XOR","GREATER_THAN","_foldBinaryFloatOrIntToBool","GREATER_THAN_OR_EQUAL","LESS_THAN","LESS_THAN_OR_EQUAL","isConst","constantValue","asVariable","VariableKind","ARGUMENT","withType","firstChild","lastChild","foldedTest","hookTest","foldedTrue","hookTrue","foldedFalse","hookFalse","asBool","dotTarget","asString","isVector","i2","Swizzle","strings","count2","set","indexOf","in_string","childAt","remove","swizzleType","result","createConstructorCall","appendChild","isStruct","count3","foldedLeft","binaryLeft","foldedRight","binaryRight","indexCount","index","asInt","isMatrix","indexCount1","index1","indexType","before","matrixStride","$arguments","value","casted","_castValue","_foldComponentConstructor","_foldStruct","_floatValues","values","asFloat","ref","left","right","leftType","rightType","VEC2","MAT2","VEC3","MAT3","VEC4","MAT4","stride","leftValues","rightValues","total","col","withFloat","stride1","result1","leftValues1","rightValues1","total1","row","stride2","result2","leftValues2","rightValues2","row1","count6","col1","count5","total2","count4","_foldFloat2","_foldInt2","withBool","withInt","argument","first","isOffMatrixDiagonal","argument1","looksTheSameAs","_foldComponentwiseUnary","argumentKind","op","_foldFloat1","_foldInt1","_foldComponentwiseBinary","leftHasComponents","rightHasComponents","leftChild","rightChild","folded1","unaryValue","floatOp","intOp","DiagnosticKind","WARNING","Diagnostic","range","text","noteRange","noteText","Log","diagnostics","warningCount","errorCount","error","warning","note","syntaxWarningUnknownExtension","syntaxErrorInvalidString","syntaxErrorDisabledExtension","extension","syntaxErrorExtraData","syntaxErrorReservedWord","toString","syntaxErrorUnexpectedToken","token","in_TokenKind","_strings","syntaxErrorExpectedToken1","expected","syntaxErrorExpectedToken2","found","syntaxErrorBadSymbolReference","syntaxErrorDuplicateSymbolDefinition","previous","syntaxErrorOutsideLoop","syntaxErrorStructVariableInitializer","syntaxErrorInsideStruct","syntaxErrorInsideFunction","syntaxErrorOutsideFunction","semanticErrorIncludeWithoutFileAccess","semanticErrorIncludeBadPath","path","JSON","stringify","syntaxErrorDifferentReturnType","syntaxErrorBadQualifier","syntaxErrorConstantRequired","syntaxErrorInvalidArraySize","syntaxErrorMissingArraySize","syntaxErrorMultidimensionalArray","syntaxErrorInvalidOperator","semanticErrorBadConversion","from","to","semanticErrorUnexpectedType","semanticErrorBadVariableType","semanticErrorBadMember","semanticErrorBadSwizzle","semanticErrorBadSwizzleAssignment","field","semanticErrorMustCallFunction","semanticErrorBadCall","semanticErrorBadConstructorValue","$constructor","semanticErrorExtraConstructorValue","semanticErrorBadConstructorCount","semanticErrorArgumentCountFunction","$function","semanticErrorArgumentCountConstructor","semanticErrorBadOverloadMatch","semanticErrorBadHookTypes","semanticErrorArrayHook","isArrayOf","semanticErrorArrayAssignment","semanticErrorBadUnaryOperator","operator","semanticErrorBadBinaryOperator","semanticErrorBadIndex","semanticErrorOutOfBoundsIndex","semanticErrorBadStorage","semanticErrorUninitializedConstant","semanticErrorMissingReturn","semanticErrorBadMatrixConstructor","STRUCT_BLOCK","VARIABLE","BLOCK","EXPRESSION","EXTENSION","FUNCTION","MODIFIER_BLOCK","PRECISION","STRUCT","VARIABLES","VERSION","PARSE_ERROR","PREFIX_DECREMENT","PREFIX_INCREMENT","POSTFIX_DECREMENT","POSTFIX_INCREMENT","ASSIGN","ASSIGN_ADD","ASSIGN_DIVIDE","ASSIGN_MULTIPLY","ASSIGN_SUBTRACT","id","_createID","internalRange","_literal","_text","_parent","_firstChild","_lastChild","_previousSibling","_nextSibling","_copyMembersFrom","cloneWithoutChildren","withSymbol","withText","withRange","withInternalRange","insertChildBefore","after","isCallTarget","isAssignTarget","isUnaryAssign","isBinaryAssign","isEmptySequence","isUnary","isBinary","createDoWhile","body","isStatement","isExpression","createExpression","createFor","setup","update","createIf","yes","no","createPrecision","flags","createReturn","createStruct","block","createVariables","createWhile","createCall","createDot","createHook","createUnary","createBinary","doWhileBody","expressionValue","forSetup","forUpdate","forBody","returnValue","variablesType","whileBody","_nextID","typeParselet","context","unaryPrefix","isUnaryPrefix","Range","span","unaryPostfix","isUnaryPostfix","binaryParselet","parseInt","get1","createExpressionParser","pratt","Pratt","invalidBinaryOperator","literal","TokenKind","TRUE","FALSE","INT_LITERAL","FLOAT_LITERAL","BVEC2","BVEC3","BVEC4","IVEC2","IVEC3","IVEC4","VOID","prefix","COMPLEMENT","Precedence","UNARY_PREFIX","DECREMENT","INCREMENT","MINUS","PLUS","postfix","UNARY_POSTFIX","infix","COMPARE","REMAINDER","SHIFT_LEFT","SHIFT","SHIFT_RIGHT","BITWISE_AND","BITWISE_OR","BITWISE_XOR","infixRight","ASSIGN_BITWISE_AND","ASSIGN_BITWISE_OR","ASSIGN_BITWISE_XOR","ASSIGN_REMAINDER","ASSIGN_SHIFT_LEFT","ASSIGN_SHIFT_RIGHT","IDENTIFIER","find","requiredExtension","compilationData","COMMA","spanSince","parselet","MEMBER","next","current","expect","LEFT_PARENTHESIS","LOWEST","RIGHT_PARENTHESIS","parseCommaSeparatedList","LEFT_BRACKET","peek","RIGHT_BRACKET","unexpectedToken","QUESTION","middle","COLON","stop","isFirst","eat","parseDoWhile","pushScope","LOOP","parseStatement","LOCAL","popScope","checkForSemicolon","parseExportOrImport","old","EXPORT","SymbolFlags","EXPORTED","IMPORTED","LEFT_BRACE","parseStatements","RIGHT_BRACE","statement","parseExtension","variable","_knownWebGLExtensions","_extensionBehaviors","behavior","parseFor","SEMICOLON","parseFlags","parseType","ParseTypeMode","REPORT_ERRORS","IGNORE_ERRORS","parseAfterType","Allow","AVOID_FUNCTIONS","parseIf","ELSE","parseVersion","parseWhile","parseReturn","parsePrecision","flag","LOWP","MEDIUMP","HIGHP","parseStruct","StructSymbol","tryToDefineUniquelyInScope","END_OF_FILE","parseVariables","checkForLoopAndSemicolon","allow","resume","parseFunction","mode","DO","IMPORT","parseBlock","ALLOW_FUNCTIONS","checkStatementLocation","isOutsideFunction","shouldBeOutsideFunction","parseInclude","STRING_LITERAL","e","nestedContext","ParserContext","ATTRIBUTE","CONST","IN","INOUT","OUT","UNIFORM","VARYING","SAMPLER2D","SAMPLERCUBE","originalScope","FunctionSymbol","returnType","argumentFlags","argumentType","argumentName","VariableSymbol","parseArraySize","symbols","hasBlock","define","isFunction","link","asFunction","previousOverload","hasSameArgumentTypesAs","sibling","redefine","arrayCount","resolveNode","checkConversion","arrayType","assign","INCLUDE","_tokens","_index","_scope","end","start","lineColumn","line","rangeAtEnd","newScope","Parselet","precedence","_table","in_IntMap","created","callback","self","slice2","contents","slice","offsetStart","offsetEnd","indexToLineColumn","_log","_data","_controlFlow","_versions","_generatedExtensions","_returnType","_resolveChildren","_resolveAsExpression","containsArray","_resolveBlockOrStatement","symbol1","type1","containsSampler","_resolveCall","_resolveDot","symbol2","isVariable","_resolveUnary","_resolveBinary","_checkStorage","valueType","isIntOrFloat","isSame","hasFloatComponents","hasIntComponents","canUseEqualityOperators","hasError","_resolveFunctionOverloads","_resolveConstructor","_validateSwizzle","overloaded","overloads","overload","removeIf","overloadsBeforeTypeFilter","fromSize","toSize","overload1","variableCount","argumentCount","hasMatrixArgument","providedCount","deltaCount","isMatrixMatrixConstructor","n","label","LineColumn","column","_lineOffsets","_computeLineOffsets","step","_STRINGS_2","_STRINGS_3","_STRINGS_4","comonentType","Symbol","_resolvedType","call","INVARIANT","Token","parts","split","_tokenRegex","part","c","keyword","keywords","reservedWords","_intRegex","operators","_arrayTypes","_setContainsSampler","Exports","sourcesFromInput","input","Array","main","exports","check","args","disableRewriting","prettyPrint","keepSymbols","charCodeAt","removeLast","pop","key","insert","defaultValue","RegExp"],"mappings":"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","file":"static/js/1.b471663cd3a21694b4f7.js","sourcesContent":["(function() {\n  function __extends(derived, base) {\n    derived.prototype = Object.create(base.prototype);\n    derived.prototype.constructor = derived;\n  }\n\n  var __imul = Math.imul ? Math.imul : function(a, b) {\n    return (a * (b >>> 16) << 16) + a * (b & 65535) | 0;\n  };\n\n  function __isString(value) {\n    return typeof value === 'string';\n  }\n\n  function assert(truth) {\n    if (!truth) {\n      throw Error('Assertion failed');\n    }\n  }\n\n  var GLSLX = {};\n\n  GLSLX.RenameSymbols = {\n    ALL: 0\n  };\n\n  GLSLX.CompilerOptions = function() {\n    this.compactSyntaxTree = true;\n    this.removeWhitespace = true;\n    this.renameSymbols = GLSLX.RenameSymbols.ALL;\n    this.trimSymbols = true;\n    this.fileAccess = null;\n    this.globals = null;\n  };\n\n  GLSLX.ExtensionBehavior = {\n    DEFAULT: 0,\n    DISABLE: 1,\n    ENABLE: 2,\n    REQUIRE: 3,\n    WARN: 4\n  };\n\n  GLSLX.CompilerData = function(fileAccess) {\n    this.currentExtensions = Object.create(null);\n    this.fileAccess = fileAccess;\n    this._nextSymbolID = 0;\n  };\n\n  GLSLX.CompilerData.prototype.nextSymbolID = function() {\n    this._nextSymbolID = this._nextSymbolID + 1 | 0;\n    return this._nextSymbolID;\n  };\n\n  GLSLX.CompilerData.prototype.extensionBehavior = function(name) {\n    return in_StringMap.get(this.currentExtensions, name, GLSLX.ExtensionBehavior.DEFAULT);\n  };\n\n  GLSLX.Compiler = {};\n\n  GLSLX.Compiler.typeCheck = function(log, sources, options) {\n    if (log.hasErrors()) {\n      return null;\n    }\n\n    // Generate tokens once\n    sources.unshift(new GLSLX.Source('<api>', GLSLX.API));\n\n    if (options.globals != null) {\n      sources.unshift(new GLSLX.Source('<externs_globals>', options.globals));\n    }\n\n    for (var i = 0, list = sources, count = list.length; i < count; i = i + 1 | 0) {\n      var source = in_List.get(list, i);\n      source.tokens = GLSLX.Tokenizer.tokenize(log, source);\n    }\n\n    var global = new GLSLX.Node(GLSLX.NodeKind.GLOBAL);\n    var scope = new GLSLX.Scope(GLSLX.ScopeKind.GLOBAL, null);\n    var data = new GLSLX.CompilerData(options.fileAccess);\n    var resolver = new GLSLX.Resolver(log, data);\n\n    // Parse everything next\n    for (var i1 = 0, list1 = sources, count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\n      var source1 = in_List.get(list1, i1);\n      GLSLX.Parser.parse(log, source1.tokens, global, data, scope, resolver);\n    }\n\n    // Then run type checking\n    resolver.resolveGlobal(global);\n\n    // Always return even when there were errors since the partial result is still useful\n    return global;\n  };\n\n  GLSLX.ControlFlowAnalyzer = function() {\n    this._isLoopBreakTarget = [];\n    this._isControlFlowLive = [];\n  };\n\n  GLSLX.ControlFlowAnalyzer.prototype.pushBlock = function(node) {\n    var parent = node.parent();\n\n    // Push control flow\n    this._isControlFlowLive.push(this._isControlFlowLive.length == 0 || in_List.last(this._isControlFlowLive));\n\n    // Push loop info\n    if (parent != null && GLSLX.in_NodeKind.isLoop(parent.kind)) {\n      this._isLoopBreakTarget.push(false);\n    }\n  };\n\n  GLSLX.ControlFlowAnalyzer.prototype.popBlock = function(node) {\n    var parent = node.parent();\n\n    // Pop control flow\n    var isLive = in_List.takeLast(this._isControlFlowLive);\n\n    if (isLive) {\n      node.hasControlFlowAtEnd = true;\n    }\n\n    // Pop loop info\n    if (parent != null && GLSLX.in_NodeKind.isLoop(parent.kind) && !in_List.takeLast(this._isLoopBreakTarget) && (parent.kind == GLSLX.NodeKind.WHILE && parent.whileTest().isTrue() || parent.kind == GLSLX.NodeKind.DO_WHILE && parent.doWhileTest().isTrue() || parent.kind == GLSLX.NodeKind.FOR && (parent.forTest() == null || parent.forTest().isTrue()))) {\n      in_List.setLast(this._isControlFlowLive, false);\n    }\n  };\n\n  GLSLX.ControlFlowAnalyzer.prototype.visitStatement = function(node) {\n    if (!in_List.last(this._isControlFlowLive)) {\n      return;\n    }\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.BREAK: {\n        if (!(this._isLoopBreakTarget.length == 0)) {\n          in_List.setLast(this._isLoopBreakTarget, true);\n        }\n\n        in_List.setLast(this._isControlFlowLive, false);\n        break;\n      }\n\n      case GLSLX.NodeKind.RETURN:\n      case GLSLX.NodeKind.DISCARD:\n      case GLSLX.NodeKind.CONTINUE: {\n        in_List.setLast(this._isControlFlowLive, false);\n        break;\n      }\n\n      case GLSLX.NodeKind.IF: {\n        var test = node.ifTest();\n        var trueValue = node.ifTrue();\n        var falseValue = node.ifFalse();\n\n        if (test.isTrue()) {\n          if (!trueValue.hasControlFlowAtEnd) {\n            in_List.setLast(this._isControlFlowLive, false);\n          }\n        }\n\n        else if (test.isFalse() && falseValue != null) {\n          if (!falseValue.hasControlFlowAtEnd) {\n            in_List.setLast(this._isControlFlowLive, false);\n          }\n        }\n\n        else if (trueValue != null && falseValue != null) {\n          if (!trueValue.hasControlFlowAtEnd && !falseValue.hasControlFlowAtEnd) {\n            in_List.setLast(this._isControlFlowLive, false);\n          }\n        }\n        break;\n      }\n    }\n  };\n\n  GLSLX.Folder = {};\n\n  GLSLX.Folder.fold = function(node) {\n    if (RELEASE) {\n      return GLSLX.Folder._fold(node);\n    }\n\n    // Run sanity checks in debug mode\n    else {\n      var folded = GLSLX.Folder._fold(node);\n\n      if (folded != null) {\n        assert(folded.parent() == null);\n\n        if (folded.kind != GLSLX.NodeKind.UNKNOWN_CONSTANT) {\n          GLSLX.Folder._check(folded);\n        }\n      }\n\n      return folded;\n    }\n  };\n\n  GLSLX.Folder._check = function(node) {\n    switch (node.kind) {\n      case GLSLX.NodeKind.INT: {\n        assert(node.resolvedType == GLSLX.Type.INT && !node.hasChildren());\n        break;\n      }\n\n      case GLSLX.NodeKind.BOOL: {\n        assert(node.resolvedType == GLSLX.Type.BOOL && !node.hasChildren());\n        break;\n      }\n\n      case GLSLX.NodeKind.FLOAT: {\n        assert(node.resolvedType == GLSLX.Type.FLOAT && !node.hasChildren());\n        break;\n      }\n\n      case GLSLX.NodeKind.CALL: {\n        var target = node.callTarget();\n        assert(target.kind == GLSLX.NodeKind.TYPE);\n        assert(target.resolvedType == node.resolvedType);\n        var componentType = target.resolvedType.componentType();\n        var componentCount = target.resolvedType.componentCount();\n\n        // Native component types\n        if (componentType != null) {\n          assert(node.childCount() == (1 + componentCount | 0));\n          assert(target.resolvedType != GLSLX.Type.INT && target.resolvedType != GLSLX.Type.BOOL && target.resolvedType != GLSLX.Type.FLOAT);\n\n          for (var child = target.nextSibling(); child != null; child = child.nextSibling()) {\n            assert(child.resolvedType == componentType);\n            assert(child.kind != GLSLX.NodeKind.CALL);\n            GLSLX.Folder._check(child);\n          }\n        }\n\n        // User-defined structs\n        else {\n          var struct = target.resolvedType.symbol.asStruct();\n          var i = 0;\n          assert(node.childCount() == (1 + struct.variables.length | 0));\n\n          for (var child1 = target.nextSibling(); child1 != null; child1 = child1.nextSibling()) {\n            assert(child1.resolvedType == in_List.get(struct.variables, i).type.resolvedType);\n            GLSLX.Folder._check(child1);\n            i = i + 1 | 0;\n          }\n        }\n        break;\n      }\n\n      default: {\n        assert(false);\n        break;\n      }\n    }\n  };\n\n  GLSLX.Folder._fold = function(node) {\n    assert(node.resolvedType != null);\n\n    if (node.resolvedType == GLSLX.Type.ERROR) {\n      return null;\n    }\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.INT:\n      case GLSLX.NodeKind.FLOAT:\n      case GLSLX.NodeKind.BOOL: {\n        return node.clone();\n      }\n\n      case GLSLX.NodeKind.NAME: {\n        return GLSLX.Folder._foldName(node);\n      }\n\n      case GLSLX.NodeKind.SEQUENCE: {\n        return GLSLX.Folder._foldSequence(node);\n      }\n\n      case GLSLX.NodeKind.HOOK: {\n        return GLSLX.Folder._foldHook(node);\n      }\n\n      case GLSLX.NodeKind.DOT: {\n        return GLSLX.Folder._foldDot(node);\n      }\n\n      case GLSLX.NodeKind.INDEX: {\n        return GLSLX.Folder._foldIndex(node);\n      }\n\n      case GLSLX.NodeKind.CALL: {\n        return GLSLX.Folder._foldCall(node);\n      }\n\n      case GLSLX.NodeKind.NEGATIVE: {\n        return GLSLX.Folder._foldUnaryFloatOrInt(node, function(x) {\n          return -x;\n        }, function(x) {\n          return -x | 0;\n        });\n      }\n\n      case GLSLX.NodeKind.NOT: {\n        return GLSLX.Folder._foldUnaryBool(node, function(x) {\n          return !x;\n        });\n      }\n\n      case GLSLX.NodeKind.POSITIVE: {\n        return GLSLX.Folder._foldUnaryFloatOrInt(node, function(x) {\n          return +x;\n        }, function(x) {\n          return +x;\n        });\n      }\n\n      case GLSLX.NodeKind.ADD: {\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\n          return a + b;\n        }, function(a, b) {\n          return a + b | 0;\n        });\n      }\n\n      case GLSLX.NodeKind.SUBTRACT: {\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\n          return a - b;\n        }, function(a, b) {\n          return a - b | 0;\n        });\n      }\n\n      case GLSLX.NodeKind.MULTIPLY: {\n        return GLSLX.Folder._foldMultiply(node);\n      }\n\n      case GLSLX.NodeKind.DIVIDE: {\n        return GLSLX.Folder._foldBinaryFloatOrInt(node, function(a, b) {\n          return b != 0 ? a / b : 0;\n        }, function(a, b) {\n          return b != 0 ? a / b | 0 : 0;\n        });\n      }\n\n      case GLSLX.NodeKind.EQUAL:\n      case GLSLX.NodeKind.NOT_EQUAL: {\n        return GLSLX.Folder._foldBinaryEquality(node);\n      }\n\n      case GLSLX.NodeKind.LOGICAL_AND: {\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\n          return a && b;\n        });\n      }\n\n      case GLSLX.NodeKind.LOGICAL_OR: {\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\n          return a || b;\n        });\n      }\n\n      case GLSLX.NodeKind.LOGICAL_XOR: {\n        return GLSLX.Folder._foldBinaryBool(node, function(a, b) {\n          return a != b;\n        });\n      }\n\n      case GLSLX.NodeKind.GREATER_THAN: {\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\n          return a > b;\n        });\n      }\n\n      case GLSLX.NodeKind.GREATER_THAN_OR_EQUAL: {\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\n          return a >= b;\n        });\n      }\n\n      case GLSLX.NodeKind.LESS_THAN: {\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\n          return a < b;\n        });\n      }\n\n      case GLSLX.NodeKind.LESS_THAN_OR_EQUAL: {\n        return GLSLX.Folder._foldBinaryFloatOrIntToBool(node, function(a, b) {\n          return a <= b;\n        });\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldName = function(node) {\n    var symbol = node.symbol;\n\n    if (symbol != null && symbol.isConst()) {\n      if (symbol.constantValue != null) {\n        return symbol.constantValue.clone();\n      }\n\n      if (symbol.asVariable().kind != GLSLX.VariableKind.ARGUMENT) {\n        return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(node.resolvedType);\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldSequence = function(node) {\n    for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\n      var folded = GLSLX.Folder.fold(child);\n\n      if (folded == null || child == node.lastChild()) {\n        return folded;\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldHook = function(node) {\n    var foldedTest = GLSLX.Folder.fold(node.hookTest());\n    var foldedTrue = GLSLX.Folder.fold(node.hookTrue());\n    var foldedFalse = GLSLX.Folder.fold(node.hookFalse());\n\n    if (foldedTest != null && foldedTest.kind == GLSLX.NodeKind.BOOL && foldedTrue != null && foldedFalse != null) {\n      return foldedTest.asBool() ? foldedTrue : foldedFalse;\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldDot = function(node) {\n    var folded = GLSLX.Folder.fold(node.dotTarget());\n\n    if (folded != null && folded.kind == GLSLX.NodeKind.CALL) {\n      var resolvedType = folded.resolvedType;\n      var name = node.asString();\n\n      // Evaluate a swizzle\n      if (resolvedType.isVector()) {\n        var count = name.length;\n        var componentCount = resolvedType.componentCount();\n\n        // Find the swizzle set\n        for (var i2 = 0, list = GLSLX.Swizzle.strings(componentCount), count2 = list.length; i2 < count2; i2 = i2 + 1 | 0) {\n          var set = in_List.get(list, i2);\n\n          if (set.indexOf(in_string.get(name, 0)) != -1) {\n            if (count == 1) {\n              return folded.childAt(1 + set.indexOf(name) | 0).remove();\n            }\n\n            var swizzleType = GLSLX.Swizzle.type(resolvedType.componentType(), count);\n            var result = GLSLX.Node.createConstructorCall(swizzleType);\n\n            for (var i = 0, count1 = count; i < count1; i = i + 1 | 0) {\n              result.appendChild(folded.childAt(1 + set.indexOf(in_string.get(name, i)) | 0).clone());\n            }\n\n            return result;\n          }\n        }\n      }\n\n      // Evaluate a struct field\n      else if (resolvedType.symbol != null && resolvedType.symbol.isStruct()) {\n        var symbol = resolvedType.symbol.asStruct();\n        var variables = symbol.variables;\n        assert(folded.childCount() == (1 + variables.length | 0));\n\n        // Extract the field from the constructor call\n        for (var i1 = 0, count3 = variables.length; i1 < count3; i1 = i1 + 1 | 0) {\n          var variable = in_List.get(variables, i1);\n\n          if (variable.name == name) {\n            return folded.childAt(1 + i1 | 0).remove();\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldIndex = function(node) {\n    var foldedLeft = GLSLX.Folder.fold(node.binaryLeft());\n    var foldedRight = GLSLX.Folder.fold(node.binaryRight());\n\n    // Both children must also be constants\n    if (foldedLeft != null && foldedLeft.kind == GLSLX.NodeKind.CALL && foldedRight != null && foldedRight.kind == GLSLX.NodeKind.INT) {\n      var type = foldedLeft.resolvedType;\n\n      if (type.isVector()) {\n        var indexCount = type.indexCount();\n        var index = foldedRight.asInt();\n\n        // The index must be in range\n        if (0 <= index && index < indexCount) {\n          return foldedLeft.childAt(index + 1 | 0).remove();\n        }\n      }\n\n      // Indexing into a matrix creates a vector\n      else if (type.isMatrix()) {\n        var indexCount1 = type.indexCount();\n        var index1 = foldedRight.asInt();\n        assert(foldedLeft.childCount() == (1 + __imul(indexCount1, indexCount1) | 0));\n\n        // The index must be in range\n        if (0 <= index1 && index1 < indexCount1) {\n          var indexType = type.indexType();\n          var result = GLSLX.Node.createConstructorCall(indexType);\n          var before = foldedLeft.childAt(__imul(index1, indexCount1));\n\n          for (var i = 0, count = indexCount1; i < count; i = i + 1 | 0) {\n            result.appendChild(before.nextSibling().remove());\n          }\n\n          return result;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldCall = function(node) {\n    var target = node.callTarget();\n\n    // Only constructor calls are considered constants\n    if (target.kind != GLSLX.NodeKind.TYPE) {\n      return null;\n    }\n\n    var type = target.resolvedType;\n    var componentType = type.componentType();\n    var matrixStride = 0;\n    var $arguments = [];\n    var count = 0;\n\n    // Make sure all arguments are constants\n    for (var child = target.nextSibling(); child != null; child = child.nextSibling()) {\n      var folded = GLSLX.Folder.fold(child);\n\n      if (folded == null) {\n        return null;\n      }\n\n      // Expand values inline from constructed native types\n      if (folded.kind == GLSLX.NodeKind.CALL && componentType != null && folded.callTarget().resolvedType.componentType() != null) {\n        for (var value = folded.callTarget().nextSibling(); value != null; value = value.nextSibling()) {\n          var casted = GLSLX.Folder._castValue(componentType, value);\n\n          if (casted == null) {\n            return null;\n          }\n\n          $arguments.push(casted);\n        }\n      }\n\n      // Auto-cast values for primitive types\n      else {\n        if (componentType != null) {\n          folded = GLSLX.Folder._castValue(componentType, folded);\n\n          if (folded == null) {\n            return null;\n          }\n        }\n\n        $arguments.push(folded);\n      }\n\n      if (folded.resolvedType.isMatrix()) {\n        matrixStride = folded.resolvedType.indexCount();\n      }\n\n      count = count + 1 | 0;\n    }\n\n    // If a matrix argument is given to a matrix constructor, it is an error\n    // to have any other arguments\n    if (type.isMatrix() && matrixStride != 0 && count != 1) {\n      return null;\n    }\n\n    // Native component-based types\n    if (type.componentType() != null) {\n      return GLSLX.Folder._foldComponentConstructor($arguments, type, type.isMatrix() ? matrixStride : 0);\n    }\n\n    // User-defined struct types\n    if (type.symbol != null && type.symbol.isStruct()) {\n      return GLSLX.Folder._foldStruct($arguments, type);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._floatValues = function(node) {\n    var values = [];\n\n    for (var child = node.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\n      values.push(child.asFloat());\n    }\n\n    return values;\n  };\n\n  GLSLX.Folder._foldMultiply = function(node) {\n    var ref;\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n    var leftType = left != null ? left.resolvedType : null;\n    var rightType = right != null ? right.resolvedType : null;\n\n    if (left != null && right != null) {\n      // Vector-matrix multiply\n      if (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4) {\n        var stride = leftType.indexCount();\n        var result = GLSLX.Node.createConstructorCall(leftType);\n        var leftValues = GLSLX.Folder._floatValues(left);\n        var rightValues = GLSLX.Folder._floatValues(right);\n\n        for (var i = 0, count1 = stride; i < count1; i = i + 1 | 0) {\n          var total = 0;\n\n          for (var col = 0, count = stride; col < count; col = col + 1 | 0) {\n            total += in_List.get(leftValues, col) * in_List.get(rightValues, col + __imul(i, stride) | 0);\n          }\n\n          result.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total).withType(GLSLX.Type.FLOAT));\n        }\n\n        return result;\n      }\n\n      // Matrix-vector multiply\n      if (leftType == GLSLX.Type.MAT2 && rightType == GLSLX.Type.VEC2 || leftType == GLSLX.Type.MAT3 && rightType == GLSLX.Type.VEC3 || leftType == GLSLX.Type.MAT4 && rightType == GLSLX.Type.VEC4) {\n        var stride1 = leftType.indexCount();\n        var result1 = GLSLX.Node.createConstructorCall(rightType);\n        var leftValues1 = GLSLX.Folder._floatValues(left);\n        var rightValues1 = GLSLX.Folder._floatValues(right);\n\n        for (var i1 = 0, count3 = stride1; i1 < count3; i1 = i1 + 1 | 0) {\n          var total1 = 0;\n\n          for (var row = 0, count2 = stride1; row < count2; row = row + 1 | 0) {\n            total1 += in_List.get(leftValues1, i1 + __imul(row, stride1) | 0) * in_List.get(rightValues1, row);\n          }\n\n          result1.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total1).withType(GLSLX.Type.FLOAT));\n        }\n\n        return result1;\n      }\n\n      // Matrix-matrix multiply\n      if (leftType.isMatrix() && rightType == leftType) {\n        var stride2 = leftType.indexCount();\n        var result2 = GLSLX.Node.createConstructorCall(leftType);\n        var leftValues2 = GLSLX.Folder._floatValues(left);\n        var rightValues2 = GLSLX.Folder._floatValues(right);\n\n        for (var row1 = 0, count6 = stride2; row1 < count6; row1 = row1 + 1 | 0) {\n          for (var col1 = 0, count5 = stride2; col1 < count5; col1 = col1 + 1 | 0) {\n            var total2 = 0;\n\n            for (var i2 = 0, count4 = stride2; i2 < count4; i2 = i2 + 1 | 0) {\n              total2 += in_List.get(leftValues2, col1 + __imul(i2, stride2) | 0) * in_List.get(rightValues2, i2 + __imul(row1, stride2) | 0);\n            }\n\n            result2.appendChild(new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(total2).withType(GLSLX.Type.FLOAT));\n          }\n        }\n\n        return result2;\n      }\n\n      return (ref = GLSLX.Folder._foldFloat2(left, right, function(a, b) {\n        return a * b;\n      })) != null ? ref : GLSLX.Folder._foldInt2(left, right, function(a, b) {\n        return __imul(a, b);\n      });\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._castValue = function(type, node) {\n    var value = 0;\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.BOOL: {\n        value = +node.asBool();\n        break;\n      }\n\n      case GLSLX.NodeKind.INT: {\n        value = node.asInt();\n        break;\n      }\n\n      case GLSLX.NodeKind.FLOAT: {\n        value = node.asFloat();\n        break;\n      }\n\n      default: {\n        return null;\n      }\n    }\n\n    switch (type) {\n      case GLSLX.Type.BOOL: {\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(!!value).withType(GLSLX.Type.BOOL);\n      }\n\n      case GLSLX.Type.INT: {\n        return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(value | 0).withType(GLSLX.Type.INT);\n      }\n\n      case GLSLX.Type.FLOAT: {\n        return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(value).withType(GLSLX.Type.FLOAT);\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldComponentConstructor = function($arguments, type, matrixStride) {\n    var componentCount = type.componentCount();\n    var componentType = type.componentType();\n    var node = GLSLX.Node.createConstructorCall(type);\n    assert(componentCount > 0);\n\n    // Passing a single component as an argument always works\n    if ($arguments.length == 1) {\n      var argument = in_List.first($arguments);\n\n      if (argument.resolvedType != componentType) {\n        return null;\n      }\n\n      // When doing this with a matrix, only the diagonal is filled\n      var isMatrix = type.isMatrix();\n      var stride = type.indexCount();\n\n      // Fill the target by repeating the single component\n      for (var i = 0, count = componentCount; i < count; i = i + 1 | 0) {\n        var isOffMatrixDiagonal = isMatrix && (i % (stride + 1 | 0) | 0) != 0;\n        node.appendChild(isOffMatrixDiagonal ? new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(0).withType(GLSLX.Type.FLOAT) : argument.clone());\n      }\n    }\n\n    // If a matrix is constructed from a matrix, then each component (column i,\n    // row j) in the result that has a corresponding component (column i, row j)\n    // in the argument will be initialized from there. All other components will\n    // be initialized to the identity matrix.\n    else if (matrixStride != 0) {\n      var stride1 = type.indexCount();\n      assert(type.isMatrix());\n      assert(__imul(stride1, stride1) == componentCount);\n\n      for (var row = 0, count2 = stride1; row < count2; row = row + 1 | 0) {\n        for (var col = 0, count1 = stride1; col < count1; col = col + 1 | 0) {\n          node.appendChild(col < matrixStride && row < matrixStride ? in_List.get($arguments, col + __imul(row, matrixStride) | 0) : new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(col == row ? 1 : 0).withType(GLSLX.Type.FLOAT));\n        }\n      }\n    }\n\n    // Multiple arguments are more involved\n    else {\n      // Extra arguments are ignored\n      if ($arguments.length < componentCount) {\n        return null;\n      }\n\n      // The constructed value is represented as a constructor call\n      for (var i1 = 0, count3 = componentCount; i1 < count3; i1 = i1 + 1 | 0) {\n        var argument1 = in_List.get($arguments, i1);\n\n        // All casts should be resolved by this point\n        if (argument1.resolvedType != componentType) {\n          return null;\n        }\n\n        node.appendChild(argument1);\n      }\n    }\n\n    // Don't wrap primitive types\n    if (type.indexType() == null) {\n      return node.lastChild().remove();\n    }\n\n    return node;\n  };\n\n  GLSLX.Folder._foldStruct = function($arguments, type) {\n    var variables = type.symbol.asStruct().variables;\n    var node = GLSLX.Node.createConstructorCall(type);\n\n    // Structs can only be constructed with the exact number of arguments\n    if ($arguments.length != variables.length) {\n      return null;\n    }\n\n    // The constructed value is represented as a constructor call\n    for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\n      if (in_List.get($arguments, i).resolvedType != in_List.get(variables, i).type.resolvedType) {\n        return null;\n      }\n\n      node.appendChild(in_List.get($arguments, i));\n    }\n\n    return node;\n  };\n\n  GLSLX.Folder._foldBinaryEquality = function(node) {\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n\n    if (left != null && right != null) {\n      var value = left.looksTheSameAs(right);\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(node.kind == GLSLX.NodeKind.EQUAL ? value : !value).withType(GLSLX.Type.BOOL);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldComponentwiseUnary = function(node, componentType, argumentKind, op) {\n    if (node.kind == GLSLX.NodeKind.CALL && node.callTarget().kind == GLSLX.NodeKind.TYPE && node.callTarget().resolvedType.componentType() == componentType) {\n      var result = GLSLX.Node.createConstructorCall(node.callTarget().resolvedType);\n\n      for (var child = node.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\n        var folded = GLSLX.Folder.fold(child);\n\n        if (folded == null || folded.kind != argumentKind) {\n          return null;\n        }\n\n        result.appendChild(op(folded));\n      }\n\n      return result;\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldFloat1 = function(node, op) {\n    if (node.kind == GLSLX.NodeKind.FLOAT) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(node.asFloat())).withType(GLSLX.Type.FLOAT);\n    }\n\n    return GLSLX.Folder._foldComponentwiseUnary(node, GLSLX.Type.FLOAT, GLSLX.NodeKind.FLOAT, function(x) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(x.asFloat())).withType(GLSLX.Type.FLOAT);\n    });\n  };\n\n  GLSLX.Folder._foldInt1 = function(node, op) {\n    if (node.kind == GLSLX.NodeKind.INT) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(node.asInt())).withType(GLSLX.Type.INT);\n    }\n\n    return GLSLX.Folder._foldComponentwiseUnary(node, GLSLX.Type.INT, GLSLX.NodeKind.INT, function(x) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(x.asInt())).withType(GLSLX.Type.INT);\n    });\n  };\n\n  GLSLX.Folder._foldComponentwiseBinary = function(left, right, componentType, argumentKind, op) {\n    var leftHasComponents = left.kind == GLSLX.NodeKind.CALL && left.callTarget().kind == GLSLX.NodeKind.TYPE && left.callTarget().resolvedType.componentType() == componentType;\n    var rightHasComponents = right.kind == GLSLX.NodeKind.CALL && right.callTarget().kind == GLSLX.NodeKind.TYPE && right.callTarget().resolvedType.componentType() == componentType;\n\n    // Vector-vector binary operator\n    if (leftHasComponents && rightHasComponents && right.resolvedType == left.resolvedType) {\n      var result = GLSLX.Node.createConstructorCall(left.resolvedType);\n      var leftChild = left.callTarget().nextSibling();\n      var rightChild = right.callTarget().nextSibling();\n\n      while (leftChild != null && rightChild != null) {\n        var foldedLeft = GLSLX.Folder.fold(leftChild);\n        var foldedRight = GLSLX.Folder.fold(rightChild);\n\n        if (foldedLeft == null || foldedLeft.kind != argumentKind || foldedRight == null || foldedRight.kind != argumentKind) {\n          return null;\n        }\n\n        result.appendChild(op(foldedLeft, foldedRight));\n        leftChild = leftChild.nextSibling();\n        rightChild = rightChild.nextSibling();\n      }\n\n      if (leftChild == null && rightChild == null) {\n        return result;\n      }\n    }\n\n    // Vector-scalar binary operator\n    else if (leftHasComponents && right.kind == argumentKind) {\n      var result1 = GLSLX.Node.createConstructorCall(left.resolvedType);\n\n      for (var child = left.callTarget().nextSibling(); child != null; child = child.nextSibling()) {\n        var folded = GLSLX.Folder.fold(child);\n\n        if (folded == null || folded.kind != argumentKind) {\n          return null;\n        }\n\n        result1.appendChild(op(folded, right));\n      }\n\n      return result1;\n    }\n\n    // Scalar-vector binary operator\n    else if (left.kind == argumentKind && rightHasComponents) {\n      var result2 = GLSLX.Node.createConstructorCall(right.resolvedType);\n\n      for (var child1 = right.callTarget().nextSibling(); child1 != null; child1 = child1.nextSibling()) {\n        var folded1 = GLSLX.Folder.fold(child1);\n\n        if (folded1 == null || folded1.kind != argumentKind) {\n          return null;\n        }\n\n        result2.appendChild(op(left, folded1));\n      }\n\n      return result2;\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldFloat2 = function(left, right, op) {\n    if (left.kind == GLSLX.NodeKind.FLOAT && right.kind == GLSLX.NodeKind.FLOAT) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(left.asFloat(), right.asFloat())).withType(GLSLX.Type.FLOAT);\n    }\n\n    return GLSLX.Folder._foldComponentwiseBinary(left, right, GLSLX.Type.FLOAT, GLSLX.NodeKind.FLOAT, function(a, b) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(op(a.asFloat(), b.asFloat())).withType(GLSLX.Type.FLOAT);\n    });\n  };\n\n  GLSLX.Folder._foldInt2 = function(left, right, op) {\n    if (left.kind == GLSLX.NodeKind.INT && right.kind == GLSLX.NodeKind.INT) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(left.asInt(), right.asInt())).withType(GLSLX.Type.INT);\n    }\n\n    return GLSLX.Folder._foldComponentwiseBinary(left, right, GLSLX.Type.INT, GLSLX.NodeKind.INT, function(a, b) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(op(a.asInt(), b.asInt())).withType(GLSLX.Type.INT);\n    });\n  };\n\n  GLSLX.Folder._foldUnaryBool = function(node, op) {\n    var value = GLSLX.Folder.fold(node.unaryValue());\n\n    if (value != null && value.kind == GLSLX.NodeKind.BOOL) {\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(value.asBool())).withType(GLSLX.Type.BOOL);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldUnaryFloatOrInt = function(node, floatOp, intOp) {\n    var ref;\n    var value = GLSLX.Folder.fold(node.unaryValue());\n\n    if (value != null) {\n      return (ref = GLSLX.Folder._foldFloat1(value, floatOp)) != null ? ref : GLSLX.Folder._foldInt1(value, intOp);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldBinaryBool = function(node, op) {\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n\n    if (left != null && right != null && left.kind == GLSLX.NodeKind.BOOL && right.kind == GLSLX.NodeKind.BOOL) {\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asBool(), right.asBool())).withType(GLSLX.Type.BOOL);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldBinaryFloatOrInt = function(node, floatOp, intOp) {\n    var ref;\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n\n    if (left != null && right != null) {\n      return (ref = GLSLX.Folder._foldFloat2(left, right, floatOp)) != null ? ref : GLSLX.Folder._foldInt2(left, right, intOp);\n    }\n\n    return null;\n  };\n\n  GLSLX.Folder._foldBinaryFloatOrIntToBool = function(node, op) {\n    var left = GLSLX.Folder.fold(node.binaryLeft());\n    var right = GLSLX.Folder.fold(node.binaryRight());\n\n    // The comparison operators only work on scalars in GLSL. To do comparisons\n    // on vectors, the functions greaterThan(), lessThan(), greaterThanEqual(),\n    // and lessThanEqual() must be used.\n    if (left != null && right != null) {\n      if (left.kind == GLSLX.NodeKind.FLOAT && right.kind == GLSLX.NodeKind.FLOAT) {\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asFloat(), right.asFloat())).withType(GLSLX.Type.BOOL);\n      }\n\n      if (left.kind == GLSLX.NodeKind.INT && right.kind == GLSLX.NodeKind.INT) {\n        return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(op(left.asInt(), right.asInt())).withType(GLSLX.Type.BOOL);\n      }\n    }\n\n    return null;\n  };\n\n  GLSLX.DiagnosticKind = {\n    ERROR: 0,\n    WARNING: 1\n  };\n\n  GLSLX.Diagnostic = function(kind, range, text) {\n    this.kind = kind;\n    this.range = range;\n    this.text = text;\n    this.noteRange = null;\n    this.noteText = '';\n  };\n\n  GLSLX.Log = function() {\n    this.diagnostics = [];\n    this.warningCount = 0;\n    this.errorCount = 0;\n  };\n\n  GLSLX.Log.prototype.hasErrors = function() {\n    return this.errorCount != 0;\n  };\n\n  GLSLX.Log.prototype.error = function(range, text) {\n    this.diagnostics.push(new GLSLX.Diagnostic(GLSLX.DiagnosticKind.ERROR, range, text));\n    this.errorCount = this.errorCount + 1 | 0;\n  };\n\n  GLSLX.Log.prototype.warning = function(range, text) {\n    this.diagnostics.push(new GLSLX.Diagnostic(GLSLX.DiagnosticKind.WARNING, range, text));\n    this.warningCount = this.warningCount + 1 | 0;\n  };\n\n  GLSLX.Log.prototype.note = function(range, text) {\n    var last = in_List.last(this.diagnostics);\n    last.noteRange = range;\n    last.noteText = text;\n  };\n\n  GLSLX.Log.prototype.syntaxWarningUnknownExtension = function(range, name) {\n    this.warning(range, 'The extension \"' + name + '\" is not in the known list of valid WebGL extensions');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInvalidString = function(range) {\n    this.error(range, 'Invalid string literal');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorDisabledExtension = function(range, name, extension) {\n    this.error(range, 'Cannot use \"' + name + '\" from disabled extension \"' + extension + '\"');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorExtraData = function(range, text) {\n    this.error(range, 'Syntax error \"' + text + '\"');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorReservedWord = function(range) {\n    this.error(range, '\"' + range.toString() + '\" is a reserved word');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorUnexpectedToken = function(token) {\n    this.error(token.range, 'Unexpected ' + in_List.get(GLSLX.in_TokenKind._strings, token.kind));\n  };\n\n  GLSLX.Log.prototype.syntaxErrorExpectedToken1 = function(range, expected) {\n    this.error(range, 'Expected ' + in_List.get(GLSLX.in_TokenKind._strings, expected));\n  };\n\n  GLSLX.Log.prototype.syntaxErrorExpectedToken2 = function(range, found, expected) {\n    this.error(range, 'Expected ' + in_List.get(GLSLX.in_TokenKind._strings, expected) + ' but found ' + in_List.get(GLSLX.in_TokenKind._strings, found));\n  };\n\n  GLSLX.Log.prototype.syntaxErrorBadSymbolReference = function(range) {\n    this.error(range, 'There is no symbol called \"' + range.toString() + '\" in the current scope');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorDuplicateSymbolDefinition = function(range, previous) {\n    this.error(range, 'There is already a symbol called \"' + range.toString() + '\" in the current scope');\n    this.note(previous, 'The previous definition of \"' + previous.toString() + '\" is here');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorOutsideLoop = function(range) {\n    this.error(range, 'This statement cannot be used outside a loop');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorStructVariableInitializer = function(range) {\n    this.error(range, 'Cannot initialize struct variables');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInsideStruct = function(range) {\n    this.error(range, 'This statement cannot be used inside a struct');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInsideFunction = function(range) {\n    this.error(range, 'This statement cannot be used inside a function');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorOutsideFunction = function(range) {\n    this.error(range, 'This statement cannot be used outside a function');\n  };\n\n  GLSLX.Log.prototype.semanticErrorIncludeWithoutFileAccess = function(range) {\n    this.error(range, 'Cannot include files without access to a file system');\n  };\n\n  GLSLX.Log.prototype.semanticErrorIncludeBadPath = function(range, path) {\n    this.error(range, 'Cannot read the file ' + JSON.stringify(path));\n  };\n\n  GLSLX.Log.prototype.syntaxErrorDifferentReturnType = function(range, name, type, expected, previous) {\n    this.error(range, 'Cannot change the return type of \"' + name + '\" to type \"' + type.toString() + '\"');\n    this.note(previous, 'The forward declaration of \"' + name + '\" has a return type of \"' + expected.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorBadQualifier = function(range) {\n    this.error(range, 'Cannot use this qualifier here');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorConstantRequired = function(range) {\n    this.error(range, 'This value must be a compile-time constant');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInvalidArraySize = function(range, count) {\n    this.error(range, 'Cannot declare an array with a size of \"' + count.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorMissingArraySize = function(range) {\n    this.error(range, 'All array sizes must be specified');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorMultidimensionalArray = function(range) {\n    this.error(range, 'Multidimensional arrays are not a part of the language');\n  };\n\n  GLSLX.Log.prototype.syntaxErrorInvalidOperator = function(range) {\n    this.error(range, 'The operator \"' + range.toString() + '\" is reserved and cannot be used');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadConversion = function(range, from, to) {\n    this.error(range, 'Cannot convert from type \"' + from.toString() + '\" to type \"' + to.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorUnexpectedType = function(range, type) {\n    this.error(range, 'Unexpected type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadVariableType = function(range, type) {\n    this.error(range, 'Cannot create a variable of type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadMember = function(range, type, name) {\n    this.error(range, 'Cannot find \"' + name + '\" on type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadSwizzle = function(range, type, name) {\n    this.error(range, 'Invalid swizzle \"' + name + '\" on type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadSwizzleAssignment = function(range, field) {\n    this.error(range, 'The field \"' + field + '\" cannot be specified multiple times when used as a storage location');\n  };\n\n  GLSLX.Log.prototype.semanticErrorMustCallFunction = function(range, name) {\n    this.error(range, 'The function \"' + name + '\" must be called');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadCall = function(range, type) {\n    this.error(range, 'Cannot call type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadConstructorValue = function(range, type, $constructor) {\n    this.error(range, 'Cannot use value of type \"' + type.toString() + '\" when constructing type \"' + $constructor.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorExtraConstructorValue = function(range, type, count, total) {\n    this.error(range, 'The constructor for type \"' + type.toString() + '\" only takes ' + count.toString() + ' argument' + (count != 1 ? 's' : '') + ' and this argument would bring the total to ' + total.toString());\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadConstructorCount = function(range, type, count) {\n    this.error(range, 'Cannot construct type \"' + type.toString() + '\" with ' + count.toString() + ' argument' + (count != 1 ? 's' : ''));\n  };\n\n  GLSLX.Log.prototype.semanticErrorArgumentCountFunction = function(range, expected, found, name, $function) {\n    this.error(range, 'Expected ' + expected.toString() + ' argument' + (expected != 1 ? 's' : '') + ' but found ' + found.toString() + ' argument' + (found != 1 ? 's' : '') + ' when calling function \"' + name + '\"');\n\n    if ($function != null) {\n      this.note($function, 'The definition of function \"' + name + '\" is here');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorArgumentCountConstructor = function(range, expected, found, name, struct) {\n    this.error(range, 'Expected ' + expected.toString() + ' argument' + (expected != 1 ? 's' : '') + ' but found ' + found.toString() + ' argument' + (found != 1 ? 's' : '') + ' when constructing type \"' + name + '\"');\n\n    if (struct != null) {\n      this.note(struct, 'The definition of struct \"' + name + '\" is here');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadOverloadMatch = function(range, name) {\n    this.error(range, 'No matching overload for function \"' + name + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadHookTypes = function(range, left, right) {\n    this.error(range, 'Cannot merge type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorArrayHook = function(range, type) {\n    if (type.isArrayOf != null) {\n      this.error(range, 'Cannot use a conditional expression with array type \"' + type.toString() + '\"');\n    }\n\n    else {\n      this.error(range, 'Cannot use a conditional expression with type \"' + type.toString() + '\" because it contains an array');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorArrayAssignment = function(range, type) {\n    if (type.isArrayOf != null) {\n      this.error(range, 'Cannot assign to array type \"' + type.toString() + '\"');\n    }\n\n    else {\n      this.error(range, 'Cannot assign to type \"' + type.toString() + '\" because it contains an array');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadUnaryOperator = function(range, operator, type) {\n    this.error(range, 'No unary operator \"' + operator + '\" for type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadBinaryOperator = function(range, operator, left, right) {\n    if (left == right) {\n      this.error(range, 'There is no operator \"' + operator + '\" defined for type \"' + left.toString() + '\"');\n    }\n\n    else {\n      this.error(range, 'No binary operator \"' + operator + '\" for type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\n    }\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadIndex = function(range, left, right) {\n    this.error(range, 'No index operator for type \"' + left.toString() + '\" and type \"' + right.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorOutOfBoundsIndex = function(range, value, type) {\n    this.error(range, 'Index \"' + value.toString() + '\" is out of bounds for type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadStorage = function(range) {\n    this.error(range, 'Cannot store to this location');\n  };\n\n  GLSLX.Log.prototype.semanticErrorUninitializedConstant = function(range) {\n    this.error(range, 'Constants must be initialized');\n  };\n\n  GLSLX.Log.prototype.semanticErrorMissingReturn = function(range, name, type) {\n    this.error(range, 'All control paths for \"' + name + '\" must return a value of type \"' + type.toString() + '\"');\n  };\n\n  GLSLX.Log.prototype.semanticErrorBadMatrixConstructor = function(range) {\n    this.error(range, 'If a matrix argument is given to a matrix constructor, it is an error to have any other arguments');\n  };\n\n  GLSLX.NodeKind = {\n    // Other\n    GLOBAL: 0,\n    STRUCT_BLOCK: 1,\n    VARIABLE: 2,\n\n    // Statements\n    BLOCK: 3,\n    BREAK: 4,\n    CONTINUE: 5,\n    DISCARD: 6,\n    DO_WHILE: 7,\n    EXPRESSION: 8,\n    EXTENSION: 9,\n    FOR: 10,\n    FUNCTION: 11,\n    IF: 12,\n    MODIFIER_BLOCK: 13,\n    PRECISION: 14,\n    RETURN: 15,\n    STRUCT: 16,\n    VARIABLES: 17,\n    VERSION: 18,\n    WHILE: 19,\n\n    // Expressions\n    CALL: 20,\n    DOT: 21,\n    HOOK: 22,\n    NAME: 23,\n    PARSE_ERROR: 24,\n    SEQUENCE: 25,\n    TYPE: 26,\n    UNKNOWN_CONSTANT: 27,\n\n    // Literals\n    BOOL: 28,\n    FLOAT: 29,\n    INT: 30,\n\n    // Unary prefix\n    NEGATIVE: 31,\n    NOT: 32,\n    POSITIVE: 33,\n\n    // Unary prefix assign\n    PREFIX_DECREMENT: 34,\n    PREFIX_INCREMENT: 35,\n\n    // Unary postfix assign\n    POSTFIX_DECREMENT: 36,\n    POSTFIX_INCREMENT: 37,\n\n    // Binary\n    ADD: 38,\n    DIVIDE: 39,\n    EQUAL: 40,\n    GREATER_THAN: 41,\n    GREATER_THAN_OR_EQUAL: 42,\n    INDEX: 43,\n    LESS_THAN: 44,\n    LESS_THAN_OR_EQUAL: 45,\n    LOGICAL_AND: 46,\n    LOGICAL_OR: 47,\n    LOGICAL_XOR: 48,\n    MULTIPLY: 49,\n    NOT_EQUAL: 50,\n    SUBTRACT: 51,\n\n    // Binary assignment\n    ASSIGN: 52,\n    ASSIGN_ADD: 53,\n    ASSIGN_DIVIDE: 54,\n    ASSIGN_MULTIPLY: 55,\n    ASSIGN_SUBTRACT: 56\n  };\n\n  GLSLX.Node = function(kind) {\n    this.id = GLSLX.Node._createID();\n    this.kind = kind;\n    this.range = null;\n    this.internalRange = null;\n    this.symbol = null;\n    this.resolvedType = null;\n    this._literal = 0;\n    this._text = null;\n    this._parent = null;\n    this._firstChild = null;\n    this._lastChild = null;\n    this._previousSibling = null;\n    this._nextSibling = null;\n    this.hasControlFlowAtEnd = false;\n  };\n\n  GLSLX.Node.prototype._copyMembersFrom = function(node) {\n    this.kind = node.kind;\n    this.range = node.range;\n    this.internalRange = node.internalRange;\n    this.symbol = node.symbol;\n    this.resolvedType = node.resolvedType;\n    this._literal = node._literal;\n    this._text = node._text;\n  };\n\n  GLSLX.Node.prototype.cloneWithoutChildren = function() {\n    var clone = new GLSLX.Node(this.kind);\n    clone._copyMembersFrom(this);\n    return clone;\n  };\n\n  GLSLX.Node.prototype.clone = function() {\n    var clone = this.cloneWithoutChildren();\n\n    for (var child = this._firstChild; child != null; child = child._nextSibling) {\n      clone.appendChild(child.clone());\n    }\n\n    return clone;\n  };\n\n  GLSLX.Node.prototype.parent = function() {\n    return this._parent;\n  };\n\n  GLSLX.Node.prototype.firstChild = function() {\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.lastChild = function() {\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.nextSibling = function() {\n    return this._nextSibling;\n  };\n\n  // This is cheaper than childCount == 0\n  GLSLX.Node.prototype.hasChildren = function() {\n    return this._firstChild != null;\n  };\n\n  GLSLX.Node.prototype.childCount = function() {\n    var count = 0;\n\n    for (var child = this._firstChild; child != null; child = child._nextSibling) {\n      count = count + 1 | 0;\n    }\n\n    return count;\n  };\n\n  GLSLX.Node.prototype.childAt = function(index) {\n    assert(0 <= index && index < this.childCount());\n    var child = this._firstChild;\n\n    while (index != 0) {\n      child = child._nextSibling;\n      index = index - 1 | 0;\n    }\n\n    return child;\n  };\n\n  GLSLX.Node.prototype.withType = function(value) {\n    this.resolvedType = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withSymbol = function(value) {\n    this.symbol = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withBool = function(value) {\n    this._literal = +value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withInt = function(value) {\n    this._literal = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withFloat = function(value) {\n    this._literal = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withText = function(value) {\n    this._text = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withRange = function(value) {\n    this.range = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.withInternalRange = function(value) {\n    this.internalRange = value;\n    return this;\n  };\n\n  GLSLX.Node.prototype.appendChild = function(node) {\n    if (node == null) {\n      return this;\n    }\n\n    assert(node != this);\n    assert(node._parent == null);\n    assert(node._previousSibling == null);\n    assert(node._nextSibling == null);\n    node._parent = this;\n\n    if (this.hasChildren()) {\n      node._previousSibling = this._lastChild;\n      this._lastChild._nextSibling = node;\n      this._lastChild = node;\n    }\n\n    else {\n      this._lastChild = this._firstChild = node;\n    }\n\n    return this;\n  };\n\n  GLSLX.Node.prototype.remove = function() {\n    assert(this._parent != null);\n\n    if (this._previousSibling != null) {\n      assert(this._previousSibling._nextSibling == this);\n      this._previousSibling._nextSibling = this._nextSibling;\n    }\n\n    else {\n      assert(this._parent._firstChild == this);\n      this._parent._firstChild = this._nextSibling;\n    }\n\n    if (this._nextSibling != null) {\n      assert(this._nextSibling._previousSibling == this);\n      this._nextSibling._previousSibling = this._previousSibling;\n    }\n\n    else {\n      assert(this._parent._lastChild == this);\n      this._parent._lastChild = this._previousSibling;\n    }\n\n    this._parent = null;\n    this._previousSibling = null;\n    this._nextSibling = null;\n    return this;\n  };\n\n  GLSLX.Node.prototype.insertChildBefore = function(after, before) {\n    if (before == null) {\n      return this;\n    }\n\n    assert(before != after);\n    assert(before._parent == null);\n    assert(before._previousSibling == null);\n    assert(before._nextSibling == null);\n    assert(after == null || after._parent == this);\n\n    if (after == null) {\n      return this.appendChild(before);\n    }\n\n    before._parent = this;\n    before._previousSibling = after._previousSibling;\n    before._nextSibling = after;\n\n    if (after._previousSibling != null) {\n      assert(after == after._previousSibling._nextSibling);\n      after._previousSibling._nextSibling = before;\n    }\n\n    else {\n      assert(after == this._firstChild);\n      this._firstChild = before;\n    }\n\n    after._previousSibling = before;\n    return this;\n  };\n\n  GLSLX.Node.prototype.isTrue = function() {\n    return this.kind == GLSLX.NodeKind.BOOL && this.asBool();\n  };\n\n  GLSLX.Node.prototype.isFalse = function() {\n    return this.kind == GLSLX.NodeKind.BOOL && !this.asBool();\n  };\n\n  GLSLX.Node.prototype.isCallTarget = function() {\n    return this.parent() != null && this.parent().kind == GLSLX.NodeKind.CALL && this.parent().callTarget() == this;\n  };\n\n  GLSLX.Node.prototype.isAssignTarget = function() {\n    return this.parent() != null && (GLSLX.in_NodeKind.isUnaryAssign(this.parent().kind) || GLSLX.in_NodeKind.isBinaryAssign(this.parent().kind) && this.parent().binaryLeft() == this);\n  };\n\n  GLSLX.Node.prototype.isEmptySequence = function() {\n    return this.kind == GLSLX.NodeKind.SEQUENCE && !this.hasChildren();\n  };\n\n  GLSLX.Node.prototype.looksTheSameAs = function(node) {\n    if (this.kind == node.kind) {\n      switch (this.kind) {\n        case GLSLX.NodeKind.BOOL: {\n          return this.asBool() == node.asBool();\n        }\n\n        case GLSLX.NodeKind.FLOAT: {\n          return this.asFloat() == node.asFloat();\n        }\n\n        case GLSLX.NodeKind.INT: {\n          return this.asInt() == node.asInt();\n        }\n\n        case GLSLX.NodeKind.NAME: {\n          return this.symbol == node.symbol;\n        }\n\n        case GLSLX.NodeKind.TYPE: {\n          return this.resolvedType == node.resolvedType;\n        }\n\n        case GLSLX.NodeKind.DOT: {\n          return this.dotTarget().looksTheSameAs(node.dotTarget()) && this.symbol == node.symbol && this.asString() == node.asString();\n        }\n\n        case GLSLX.NodeKind.HOOK: {\n          return this.hookTest().looksTheSameAs(node.hookTest()) && this.hookTrue().looksTheSameAs(node.hookTrue()) && this.hookFalse().looksTheSameAs(node.hookFalse());\n        }\n\n        case GLSLX.NodeKind.CALL: {\n          var left = this.firstChild();\n          var right = node.firstChild();\n\n          while (left != null && right != null) {\n            if (!left.looksTheSameAs(right)) {\n              return false;\n            }\n\n            left = left.nextSibling();\n            right = right.nextSibling();\n          }\n\n          return left == null && right == null;\n        }\n\n        default: {\n          if (GLSLX.in_NodeKind.isUnary(this.kind)) {\n            return this.unaryValue().looksTheSameAs(node.unaryValue());\n          }\n\n          if (GLSLX.in_NodeKind.isBinary(this.kind)) {\n            return this.binaryLeft().looksTheSameAs(node.binaryLeft()) && this.binaryRight().looksTheSameAs(node.binaryRight());\n          }\n          break;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  GLSLX.Node.createDoWhile = function(body, test) {\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.DO_WHILE).appendChild(body).appendChild(test);\n  };\n\n  GLSLX.Node.createExpression = function(value) {\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.EXPRESSION).appendChild(value);\n  };\n\n  GLSLX.Node.createFor = function(setup, test, update, body) {\n    assert(setup == null || GLSLX.in_NodeKind.isExpression(setup.kind) || setup.kind == GLSLX.NodeKind.VARIABLES);\n    assert(test == null || GLSLX.in_NodeKind.isExpression(test.kind));\n    assert(update == null || GLSLX.in_NodeKind.isExpression(update.kind));\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.FOR).appendChild(setup == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : setup).appendChild(test == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : test).appendChild(update == null ? new GLSLX.Node(GLSLX.NodeKind.SEQUENCE) : update).appendChild(body);\n  };\n\n  GLSLX.Node.createIf = function(test, yes, no) {\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\n    assert(GLSLX.in_NodeKind.isStatement(yes.kind));\n    assert(no == null || GLSLX.in_NodeKind.isStatement(no.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.IF).appendChild(test).appendChild(yes).appendChild(no);\n  };\n\n  GLSLX.Node.createPrecision = function(flags, type) {\n    assert(GLSLX.in_NodeKind.isExpression(type.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.PRECISION).withInt(flags).appendChild(type);\n  };\n\n  GLSLX.Node.createReturn = function(value) {\n    assert(value == null || GLSLX.in_NodeKind.isExpression(value.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.RETURN).appendChild(value);\n  };\n\n  GLSLX.Node.createStruct = function(symbol, block, variables) {\n    assert(block.kind == GLSLX.NodeKind.STRUCT_BLOCK);\n    assert(variables == null || variables.kind == GLSLX.NodeKind.VARIABLES);\n    return new GLSLX.Node(GLSLX.NodeKind.STRUCT).withSymbol(symbol).appendChild(block).appendChild(variables);\n  };\n\n  GLSLX.Node.createVariables = function(flags, type) {\n    assert(GLSLX.in_NodeKind.isExpression(type.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.VARIABLES).withInt(flags).appendChild(type);\n  };\n\n  GLSLX.Node.createWhile = function(test, body) {\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\n    assert(GLSLX.in_NodeKind.isStatement(body.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.WHILE).appendChild(test).appendChild(body);\n  };\n\n  GLSLX.Node.createCall = function(value) {\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.CALL).appendChild(value);\n  };\n\n  GLSLX.Node.createConstructorCall = function(type) {\n    return GLSLX.Node.createCall(new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type)).withType(type);\n  };\n\n  GLSLX.Node.createDot = function(value, text) {\n    assert(GLSLX.in_NodeKind.isExpression(value.kind));\n    assert(text != null);\n    return new GLSLX.Node(GLSLX.NodeKind.DOT).appendChild(value).withText(text);\n  };\n\n  GLSLX.Node.createHook = function(test, yes, no) {\n    assert(GLSLX.in_NodeKind.isExpression(test.kind));\n    assert(GLSLX.in_NodeKind.isExpression(yes.kind));\n    assert(GLSLX.in_NodeKind.isExpression(no.kind));\n    return new GLSLX.Node(GLSLX.NodeKind.HOOK).appendChild(test).appendChild(yes).appendChild(no);\n  };\n\n  GLSLX.Node.createUnary = function(kind, value) {\n    assert(GLSLX.in_NodeKind.isUnary(kind));\n    return new GLSLX.Node(kind).appendChild(value);\n  };\n\n  GLSLX.Node.createBinary = function(kind, left, right) {\n    assert(GLSLX.in_NodeKind.isBinary(kind));\n    return new GLSLX.Node(kind).appendChild(left).appendChild(right);\n  };\n\n  GLSLX.Node.prototype.doWhileBody = function() {\n    assert(this.kind == GLSLX.NodeKind.DO_WHILE);\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isStatement(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.doWhileTest = function() {\n    assert(this.kind == GLSLX.NodeKind.DO_WHILE);\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.expressionValue = function() {\n    assert(this.kind == GLSLX.NodeKind.EXPRESSION);\n    assert(this.childCount() == 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.forSetup = function() {\n    assert(this.kind == GLSLX.NodeKind.FOR);\n    assert(this.childCount() == 4);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind) || this._firstChild.kind == GLSLX.NodeKind.VARIABLES);\n    return this._firstChild.isEmptySequence() ? null : this._firstChild;\n  };\n\n  GLSLX.Node.prototype.forTest = function() {\n    assert(this.kind == GLSLX.NodeKind.FOR);\n    assert(this.childCount() == 4);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild._nextSibling.kind) || this._firstChild._nextSibling.kind == GLSLX.NodeKind.VARIABLES);\n    return this._firstChild._nextSibling.isEmptySequence() ? null : this._firstChild._nextSibling;\n  };\n\n  GLSLX.Node.prototype.forUpdate = function() {\n    assert(this.kind == GLSLX.NodeKind.FOR);\n    assert(this.childCount() == 4);\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild._previousSibling.kind));\n    return this._lastChild._previousSibling.isEmptySequence() ? null : this._lastChild._previousSibling;\n  };\n\n  GLSLX.Node.prototype.forBody = function() {\n    assert(this.kind == GLSLX.NodeKind.FOR);\n    assert(this.childCount() == 4);\n    assert(GLSLX.in_NodeKind.isStatement(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.ifTest = function() {\n    assert(this.kind == GLSLX.NodeKind.IF);\n    assert(this.childCount() == 2 || this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.ifTrue = function() {\n    assert(this.kind == GLSLX.NodeKind.IF);\n    assert(this.childCount() == 2 || this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isStatement(this._firstChild._nextSibling.kind));\n    return this._firstChild._nextSibling;\n  };\n\n  GLSLX.Node.prototype.ifFalse = function() {\n    assert(this.kind == GLSLX.NodeKind.IF);\n    assert(this.childCount() == 2 || this.childCount() == 3);\n    assert(this._firstChild._nextSibling._nextSibling == null || GLSLX.in_NodeKind.isStatement(this._firstChild._nextSibling._nextSibling.kind));\n    return this._firstChild._nextSibling._nextSibling;\n  };\n\n  GLSLX.Node.prototype.returnValue = function() {\n    assert(this.kind == GLSLX.NodeKind.RETURN);\n    assert(this.childCount() <= 1);\n    assert(this._firstChild == null || GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.variablesType = function() {\n    assert(this.kind == GLSLX.NodeKind.VARIABLES);\n    assert(this.childCount() >= 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.whileTest = function() {\n    assert(this.kind == GLSLX.NodeKind.WHILE);\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.whileBody = function() {\n    assert(this.kind == GLSLX.NodeKind.WHILE);\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isStatement(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.callTarget = function() {\n    assert(this.kind == GLSLX.NodeKind.CALL);\n    assert(this.childCount() >= 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.dotTarget = function() {\n    assert(this.kind == GLSLX.NodeKind.DOT);\n    assert(this.childCount() == 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.hookTest = function() {\n    assert(this.kind == GLSLX.NodeKind.HOOK);\n    assert(this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.hookTrue = function() {\n    assert(this.kind == GLSLX.NodeKind.HOOK);\n    assert(this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild._nextSibling.kind));\n    return this._firstChild._nextSibling;\n  };\n\n  GLSLX.Node.prototype.hookFalse = function() {\n    assert(this.kind == GLSLX.NodeKind.HOOK);\n    assert(this.childCount() == 3);\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node.prototype.asString = function() {\n    assert(this.kind == GLSLX.NodeKind.DOT);\n    assert(this._text != null);\n    return this._text;\n  };\n\n  GLSLX.Node.prototype.asBool = function() {\n    assert(this.kind == GLSLX.NodeKind.BOOL);\n    return !!this._literal;\n  };\n\n  GLSLX.Node.prototype.asFloat = function() {\n    assert(this.kind == GLSLX.NodeKind.FLOAT);\n    return this._literal;\n  };\n\n  GLSLX.Node.prototype.asInt = function() {\n    assert(this.kind == GLSLX.NodeKind.INT);\n    return this._literal | 0;\n  };\n\n  GLSLX.Node.prototype.unaryValue = function() {\n    assert(GLSLX.in_NodeKind.isUnary(this.kind));\n    assert(this.childCount() == 1);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.binaryLeft = function() {\n    assert(GLSLX.in_NodeKind.isBinary(this.kind));\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isExpression(this._firstChild.kind));\n    return this._firstChild;\n  };\n\n  GLSLX.Node.prototype.binaryRight = function() {\n    assert(GLSLX.in_NodeKind.isBinary(this.kind));\n    assert(this.childCount() == 2);\n    assert(GLSLX.in_NodeKind.isExpression(this._lastChild.kind));\n    return this._lastChild;\n  };\n\n  GLSLX.Node._createID = function() {\n    GLSLX.Node._nextID = GLSLX.Node._nextID + 1 | 0;\n    return GLSLX.Node._nextID;\n  };\n\n  GLSLX.Parser = {};\n\n  GLSLX.Parser.typeParselet = function(type) {\n    return function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type).withRange(token.range);\n    };\n  };\n\n  GLSLX.Parser.unaryPrefix = function(kind) {\n    assert(GLSLX.in_NodeKind.isUnaryPrefix(kind));\n    return function(context, token, value) {\n      return GLSLX.Node.createUnary(kind, value).withRange(GLSLX.Range.span(token.range, value.range)).withInternalRange(token.range);\n    };\n  };\n\n  GLSLX.Parser.unaryPostfix = function(kind) {\n    assert(GLSLX.in_NodeKind.isUnaryPostfix(kind));\n    return function(context, value, token) {\n      return GLSLX.Node.createUnary(kind, value).withRange(GLSLX.Range.span(value.range, token.range)).withInternalRange(token.range);\n    };\n  };\n\n  GLSLX.Parser.binaryParselet = function(kind) {\n    assert(GLSLX.in_NodeKind.isBinary(kind));\n    return function(context, left, token, right) {\n      return GLSLX.Node.createBinary(kind, left, right).withRange(GLSLX.Range.span(left.range, right.range)).withInternalRange(token.range);\n    };\n  };\n\n  GLSLX.Parser.parseInt = function(text) {\n    if (text.length > 1 && in_string.get1(text, 0) == 48 && (in_string.get1(text, 1) != 120 && in_string.get1(text, 1) != 88)) {\n      return parseInt(text, 8);\n    }\n\n    return text | 0;\n  };\n\n  GLSLX.Parser.createExpressionParser = function() {\n    var pratt = new GLSLX.Pratt();\n    var invalidUnaryOperator = function(context, token, value) {\n      context.log.syntaxErrorInvalidOperator(token.range);\n      return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(GLSLX.Type.ERROR).withRange(GLSLX.Range.span(token.range, value.range));\n    };\n    var invalidBinaryOperator = function(context, left, token, right) {\n      context.log.syntaxErrorInvalidOperator(token.range);\n      return new GLSLX.Node(GLSLX.NodeKind.UNKNOWN_CONSTANT).withType(GLSLX.Type.ERROR).withRange(GLSLX.Range.span(left.range, right.range));\n    };\n    pratt.literal(GLSLX.TokenKind.TRUE, function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(true).withType(GLSLX.Type.BOOL).withRange(token.range);\n    });\n    pratt.literal(GLSLX.TokenKind.FALSE, function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.BOOL).withBool(false).withType(GLSLX.Type.BOOL).withRange(token.range);\n    });\n    pratt.literal(GLSLX.TokenKind.INT_LITERAL, function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.INT).withInt(GLSLX.Parser.parseInt(token.range.toString())).withType(GLSLX.Type.INT).withRange(token.range);\n    });\n    pratt.literal(GLSLX.TokenKind.FLOAT_LITERAL, function(context, token) {\n      return new GLSLX.Node(GLSLX.NodeKind.FLOAT).withFloat(+token.range.toString()).withType(GLSLX.Type.FLOAT).withRange(token.range);\n    });\n    pratt.literal(GLSLX.TokenKind.BOOL, GLSLX.Parser.typeParselet(GLSLX.Type.BOOL));\n    pratt.literal(GLSLX.TokenKind.BVEC2, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC2));\n    pratt.literal(GLSLX.TokenKind.BVEC3, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC3));\n    pratt.literal(GLSLX.TokenKind.BVEC4, GLSLX.Parser.typeParselet(GLSLX.Type.BVEC4));\n    pratt.literal(GLSLX.TokenKind.FLOAT, GLSLX.Parser.typeParselet(GLSLX.Type.FLOAT));\n    pratt.literal(GLSLX.TokenKind.INT, GLSLX.Parser.typeParselet(GLSLX.Type.INT));\n    pratt.literal(GLSLX.TokenKind.IVEC2, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC2));\n    pratt.literal(GLSLX.TokenKind.IVEC3, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC3));\n    pratt.literal(GLSLX.TokenKind.IVEC4, GLSLX.Parser.typeParselet(GLSLX.Type.IVEC4));\n    pratt.literal(GLSLX.TokenKind.MAT2, GLSLX.Parser.typeParselet(GLSLX.Type.MAT2));\n    pratt.literal(GLSLX.TokenKind.MAT3, GLSLX.Parser.typeParselet(GLSLX.Type.MAT3));\n    pratt.literal(GLSLX.TokenKind.MAT4, GLSLX.Parser.typeParselet(GLSLX.Type.MAT4));\n    pratt.literal(GLSLX.TokenKind.VEC2, GLSLX.Parser.typeParselet(GLSLX.Type.VEC2));\n    pratt.literal(GLSLX.TokenKind.VEC3, GLSLX.Parser.typeParselet(GLSLX.Type.VEC3));\n    pratt.literal(GLSLX.TokenKind.VEC4, GLSLX.Parser.typeParselet(GLSLX.Type.VEC4));\n    pratt.literal(GLSLX.TokenKind.VOID, GLSLX.Parser.typeParselet(GLSLX.Type.VOID));\n    pratt.prefix(GLSLX.TokenKind.COMPLEMENT, GLSLX.Precedence.UNARY_PREFIX, invalidUnaryOperator);\n    pratt.prefix(GLSLX.TokenKind.DECREMENT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.PREFIX_DECREMENT));\n    pratt.prefix(GLSLX.TokenKind.INCREMENT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.PREFIX_INCREMENT));\n    pratt.prefix(GLSLX.TokenKind.MINUS, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.NEGATIVE));\n    pratt.prefix(GLSLX.TokenKind.NOT, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.NOT));\n    pratt.prefix(GLSLX.TokenKind.PLUS, GLSLX.Precedence.UNARY_PREFIX, GLSLX.Parser.unaryPrefix(GLSLX.NodeKind.POSITIVE));\n    pratt.postfix(GLSLX.TokenKind.DECREMENT, GLSLX.Precedence.UNARY_POSTFIX, GLSLX.Parser.unaryPostfix(GLSLX.NodeKind.POSTFIX_DECREMENT));\n    pratt.postfix(GLSLX.TokenKind.INCREMENT, GLSLX.Precedence.UNARY_POSTFIX, GLSLX.Parser.unaryPostfix(GLSLX.NodeKind.POSTFIX_INCREMENT));\n    pratt.infix(GLSLX.TokenKind.DIVIDE, GLSLX.Precedence.MULTIPLY, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.DIVIDE));\n    pratt.infix(GLSLX.TokenKind.EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.EQUAL));\n    pratt.infix(GLSLX.TokenKind.GREATER_THAN, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.GREATER_THAN));\n    pratt.infix(GLSLX.TokenKind.GREATER_THAN_OR_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.GREATER_THAN_OR_EQUAL));\n    pratt.infix(GLSLX.TokenKind.LESS_THAN, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LESS_THAN));\n    pratt.infix(GLSLX.TokenKind.LESS_THAN_OR_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LESS_THAN_OR_EQUAL));\n    pratt.infix(GLSLX.TokenKind.MINUS, GLSLX.Precedence.ADD, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.SUBTRACT));\n    pratt.infix(GLSLX.TokenKind.MULTIPLY, GLSLX.Precedence.MULTIPLY, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.MULTIPLY));\n    pratt.infix(GLSLX.TokenKind.NOT_EQUAL, GLSLX.Precedence.COMPARE, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.NOT_EQUAL));\n    pratt.infix(GLSLX.TokenKind.PLUS, GLSLX.Precedence.ADD, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ADD));\n    pratt.infix(GLSLX.TokenKind.REMAINDER, GLSLX.Precedence.MULTIPLY, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.SHIFT_LEFT, GLSLX.Precedence.SHIFT, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.SHIFT_RIGHT, GLSLX.Precedence.SHIFT, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.LOGICAL_OR, GLSLX.Precedence.LOGICAL_OR, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_OR));\n    pratt.infix(GLSLX.TokenKind.LOGICAL_XOR, GLSLX.Precedence.LOGICAL_XOR, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_XOR));\n    pratt.infix(GLSLX.TokenKind.LOGICAL_AND, GLSLX.Precedence.LOGICAL_AND, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.LOGICAL_AND));\n    pratt.infix(GLSLX.TokenKind.BITWISE_AND, GLSLX.Precedence.BITWISE_AND, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.BITWISE_OR, GLSLX.Precedence.BITWISE_OR, invalidBinaryOperator);\n    pratt.infix(GLSLX.TokenKind.BITWISE_XOR, GLSLX.Precedence.BITWISE_XOR, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN));\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_ADD, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_ADD));\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_AND, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_OR, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_BITWISE_XOR, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_DIVIDE, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_DIVIDE));\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_MULTIPLY, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_MULTIPLY));\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_REMAINDER, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SHIFT_LEFT, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SHIFT_RIGHT, GLSLX.Precedence.ASSIGN, invalidBinaryOperator);\n    pratt.infixRight(GLSLX.TokenKind.ASSIGN_SUBTRACT, GLSLX.Precedence.ASSIGN, GLSLX.Parser.binaryParselet(GLSLX.NodeKind.ASSIGN_SUBTRACT));\n\n    // Name\n    pratt.literal(GLSLX.TokenKind.IDENTIFIER, function(context, token) {\n      var name = token.range.toString();\n      var symbol = context.scope().find(name);\n\n      if (symbol == null) {\n        context.log.syntaxErrorBadSymbolReference(token.range);\n        return new GLSLX.Node(GLSLX.NodeKind.PARSE_ERROR).withType(GLSLX.Type.ERROR).withRange(token.range);\n      }\n\n      // Check extension usage\n      if (symbol.requiredExtension != null && context.compilationData.extensionBehavior(symbol.requiredExtension) == GLSLX.ExtensionBehavior.DISABLE) {\n        context.log.syntaxErrorDisabledExtension(token.range, name, symbol.requiredExtension);\n      }\n\n      return (symbol.isStruct() ? new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(symbol.resolvedType()) : new GLSLX.Node(GLSLX.NodeKind.NAME).withSymbol(symbol)).withRange(token.range);\n    });\n\n    // Sequence\n    pratt.infix(GLSLX.TokenKind.COMMA, GLSLX.Precedence.COMMA, function(context, left, token, right) {\n      if (left.kind != GLSLX.NodeKind.SEQUENCE) {\n        left = new GLSLX.Node(GLSLX.NodeKind.SEQUENCE).appendChild(left).withRange(left.range);\n      }\n\n      left.appendChild(right);\n      return left.withRange(context.spanSince(left.range));\n    });\n\n    // Dot\n    pratt.parselet(GLSLX.TokenKind.DOT, GLSLX.Precedence.MEMBER).infix = function(context, left) {\n      context.next();\n      var name = context.current().range;\n\n      if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n        return null;\n      }\n\n      return GLSLX.Node.createDot(left, name.toString()).withRange(context.spanSince(left.range)).withInternalRange(name);\n    };\n\n    // Group\n    pratt.parselet(GLSLX.TokenKind.LEFT_PARENTHESIS, GLSLX.Precedence.LOWEST).prefix = function(context) {\n      var token = context.next();\n      var value = pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (value == null || !context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n\n      return value.withRange(context.spanSince(token.range));\n    };\n\n    // Call\n    pratt.parselet(GLSLX.TokenKind.LEFT_PARENTHESIS, GLSLX.Precedence.UNARY_POSTFIX).infix = function(context, left) {\n      var token = context.next();\n      var node = GLSLX.Node.createCall(left);\n\n      if (!GLSLX.Parser.parseCommaSeparatedList(context, node, GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n\n      return node.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\n    };\n\n    // Index\n    pratt.parselet(GLSLX.TokenKind.LEFT_BRACKET, GLSLX.Precedence.MEMBER).infix = function(context, left) {\n      var token = context.next();\n\n      // The \"[]\" syntax isn't valid but skip over it and recover\n      if (context.peek(GLSLX.TokenKind.RIGHT_BRACKET)) {\n        context.unexpectedToken();\n        context.next();\n        return new GLSLX.Node(GLSLX.NodeKind.PARSE_ERROR).withType(GLSLX.Type.ERROR).withRange(context.spanSince(token.range));\n      }\n\n      var value = pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (value == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\n        return null;\n      }\n\n      return GLSLX.Node.createBinary(GLSLX.NodeKind.INDEX, left, value).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range));\n    };\n\n    // Hook\n    pratt.parselet(GLSLX.TokenKind.QUESTION, GLSLX.Precedence.ASSIGN).infix = function(context, left) {\n      context.next();\n      var middle = pratt.parse(context, GLSLX.Precedence.COMMA);\n\n      if (middle == null || !context.expect(GLSLX.TokenKind.COLON)) {\n        return null;\n      }\n\n      var right = pratt.parse(context, GLSLX.Precedence.COMMA);\n\n      if (right == null) {\n        return null;\n      }\n\n      return GLSLX.Node.createHook(left, middle, right).withRange(context.spanSince(left.range));\n    };\n    return pratt;\n  };\n\n  GLSLX.Parser.parseCommaSeparatedList = function(context, parent, stop) {\n    var isFirst = true;\n\n    while (!context.eat(stop)) {\n      if (!isFirst && !context.expect(GLSLX.TokenKind.COMMA)) {\n        return false;\n      }\n\n      var value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.COMMA);\n\n      if (value == null) {\n        return false;\n      }\n\n      parent.appendChild(value);\n      isFirst = false;\n    }\n\n    return true;\n  };\n\n  GLSLX.Parser.parseDoWhile = function(context) {\n    var token = context.next();\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n    if (body == null || !context.expect(GLSLX.TokenKind.WHILE) || !context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return null;\n    }\n\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n    if (test == null) {\n      return null;\n    }\n\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      return null;\n    }\n\n    context.popScope();\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createDoWhile(body, test));\n  };\n\n  GLSLX.Parser.parseExportOrImport = function(context) {\n    var token = context.next();\n    var old = context.flags;\n    context.flags |= token.kind == GLSLX.TokenKind.EXPORT ? GLSLX.SymbolFlags.EXPORTED : GLSLX.SymbolFlags.IMPORTED;\n\n    // Parse a modifier block\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACE)) {\n      var node = new GLSLX.Node(GLSLX.NodeKind.MODIFIER_BLOCK);\n\n      if (!GLSLX.Parser.parseStatements(context, node, GLSLX.VariableKind.GLOBAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\n        return null;\n      }\n\n      context.flags = old;\n      return node.withRange(context.spanSince(token.range));\n    }\n\n    // Just parse a single statement\n    var statement = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.GLOBAL);\n\n    if (statement == null) {\n      return null;\n    }\n\n    context.flags = old;\n    return statement;\n  };\n\n  GLSLX.Parser.parseExtension = function(context) {\n    var token = context.next();\n    var range = context.current().range;\n\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n      return null;\n    }\n\n    var name = range.toString();\n\n    // Parse an extension block (a non-standard addition)\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACE)) {\n      if (!(name in context.compilationData.currentExtensions)) {\n        // Silence warnings about this name\n        context.compilationData.currentExtensions[name] = GLSLX.ExtensionBehavior.DEFAULT;\n      }\n\n      var block = new GLSLX.Node(GLSLX.NodeKind.MODIFIER_BLOCK);\n\n      if (!GLSLX.Parser.parseStatements(context, block, GLSLX.VariableKind.GLOBAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\n        return null;\n      }\n\n      for (var child = block.firstChild(); child != null; child = child.nextSibling()) {\n        if (child.kind == GLSLX.NodeKind.VARIABLES) {\n          for (var variable = child.variablesType().nextSibling(); variable != null; variable = variable.nextSibling()) {\n            variable.symbol.requiredExtension = name;\n          }\n        }\n\n        else if (child.symbol != null) {\n          child.symbol.requiredExtension = name;\n        }\n      }\n\n      return block.withRange(context.spanSince(token.range));\n    }\n\n    // Warn about typos\n    if (!(name in GLSLX.Parser._knownWebGLExtensions) && !(name in context.compilationData.currentExtensions)) {\n      context.log.syntaxWarningUnknownExtension(range, name);\n    }\n\n    // Parse a regular extension pragma\n    if (!context.expect(GLSLX.TokenKind.COLON)) {\n      return null;\n    }\n\n    var text = context.current().range.toString();\n\n    if (!(text in GLSLX.Parser._extensionBehaviors)) {\n      context.unexpectedToken();\n      return null;\n    }\n\n    context.next();\n\n    // Activate or deactivate the extension\n    var behavior = in_StringMap.get1(GLSLX.Parser._extensionBehaviors, text);\n    context.compilationData.currentExtensions[name] = behavior;\n    return new GLSLX.Node(GLSLX.NodeKind.EXTENSION).withText(name).withInt(behavior).withRange(context.spanSince(token.range)).withInternalRange(range);\n  };\n\n  GLSLX.Parser.parseFor = function(context) {\n    var token = context.next();\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return null;\n    }\n\n    // Setup\n    var setup = null;\n\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\n      // Check for a type\n      var flags = GLSLX.Parser.parseFlags(context, GLSLX.VariableKind.LOCAL);\n      var type = null;\n\n      if (flags != 0) {\n        type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\n\n        if (type == null) {\n          return null;\n        }\n      }\n\n      else {\n        type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.IGNORE_ERRORS);\n      }\n\n      // Try to parse a variable\n      if (type != null) {\n        setup = GLSLX.Parser.parseAfterType(context, token.range, flags, type, GLSLX.Parser.Allow.AVOID_FUNCTIONS);\n\n        if (setup == null) {\n          return null;\n        }\n      }\n\n      else {\n        setup = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n        if (setup == null) {\n          return null;\n        }\n\n        if (!context.expect(GLSLX.TokenKind.SEMICOLON)) {\n          return null;\n        }\n      }\n    }\n\n    // Test\n    var test = null;\n\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\n      test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (test == null) {\n        return null;\n      }\n\n      if (!context.expect(GLSLX.TokenKind.SEMICOLON)) {\n        return null;\n      }\n    }\n\n    // Update\n    var update = null;\n\n    if (!context.eat(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      update = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (update == null) {\n        return null;\n      }\n\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n    }\n\n    // Body\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n    if (body == null) {\n      return null;\n    }\n\n    context.popScope();\n    return GLSLX.Node.createFor(setup, test, update, body).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseIf = function(context) {\n    var token = context.next();\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return null;\n    }\n\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n    if (test == null) {\n      return null;\n    }\n\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      return null;\n    }\n\n    var yes = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n    if (yes == null) {\n      return null;\n    }\n\n    var no = null;\n\n    if (context.eat(GLSLX.TokenKind.ELSE)) {\n      no = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n      if (no == null) {\n        return null;\n      }\n    }\n\n    return GLSLX.Node.createIf(test, yes, no).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseVersion = function(context) {\n    var token = context.next();\n    var range = context.current().range;\n\n    if (!context.expect(GLSLX.TokenKind.INT_LITERAL)) {\n      return null;\n    }\n\n    return new GLSLX.Node(GLSLX.NodeKind.VERSION).withInt(range.toString() | 0).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseWhile = function(context) {\n    var token = context.next();\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOOP, context.scope()));\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return null;\n    }\n\n    var test = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n    if (test == null) {\n      return null;\n    }\n\n    if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      return null;\n    }\n\n    var body = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.LOCAL);\n\n    if (body == null) {\n      return null;\n    }\n\n    context.popScope();\n    return GLSLX.Node.createWhile(test, body).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseReturn = function(context) {\n    var token = context.next();\n    var value = null;\n\n    if (!context.eat(GLSLX.TokenKind.SEMICOLON)) {\n      value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (value == null) {\n        return null;\n      }\n\n      context.expect(GLSLX.TokenKind.SEMICOLON);\n    }\n\n    return GLSLX.Node.createReturn(value).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parsePrecision = function(context) {\n    var token = context.next();\n    var flag = 0;\n\n    switch (context.current().kind) {\n      case GLSLX.TokenKind.LOWP: {\n        flag = GLSLX.SymbolFlags.LOWP;\n        break;\n      }\n\n      case GLSLX.TokenKind.MEDIUMP: {\n        flag = GLSLX.SymbolFlags.MEDIUMP;\n        break;\n      }\n\n      case GLSLX.TokenKind.HIGHP: {\n        flag = GLSLX.SymbolFlags.HIGHP;\n        break;\n      }\n\n      default: {\n        context.unexpectedToken();\n        return null;\n      }\n    }\n\n    context.next();\n    var type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\n\n    if (type == null) {\n      return null;\n    }\n\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createPrecision(flag, type));\n  };\n\n  GLSLX.Parser.parseStruct = function(context, flags) {\n    var name = context.current().range;\n\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n      return null;\n    }\n\n    var symbol = new GLSLX.StructSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new GLSLX.Scope(GLSLX.ScopeKind.STRUCT, context.scope()));\n    symbol.flags |= context.flags | flags;\n\n    if (!GLSLX.Parser.tryToDefineUniquelyInScope(context, symbol)) {\n      return null;\n    }\n\n    var range = context.current().range;\n    var block = new GLSLX.Node(GLSLX.NodeKind.STRUCT_BLOCK);\n    var variables = null;\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_BRACE)) {\n      return null;\n    }\n\n    context.pushScope(symbol.scope);\n\n    while (!context.peek(GLSLX.TokenKind.RIGHT_BRACE) && !context.peek(GLSLX.TokenKind.END_OF_FILE)) {\n      var statement = GLSLX.Parser.parseStatement(context, GLSLX.VariableKind.STRUCT);\n\n      if (statement == null) {\n        return null;\n      }\n\n      if (statement.kind != GLSLX.NodeKind.VARIABLES) {\n        context.log.syntaxErrorInsideStruct(statement.range);\n        continue;\n      }\n\n      block.appendChild(statement);\n\n      for (var child = statement.variablesType().nextSibling(); child != null; child = child.nextSibling()) {\n        var variable = child.symbol.asVariable();\n        symbol.variables.push(variable);\n\n        if (variable.value != null) {\n          context.log.syntaxErrorStructVariableInitializer(variable.value.range);\n        }\n      }\n    }\n\n    context.popScope();\n\n    if (!context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\n      return null;\n    }\n\n    block.withRange(context.spanSince(range));\n\n    // Parse weird struct-variable hybrid things\n    //\n    //   struct S { int x; } y, z[2];\n    //\n    if (context.peek(GLSLX.TokenKind.IDENTIFIER)) {\n      variables = GLSLX.Parser.parseVariables(0, new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(symbol.resolvedType()), context.next().range, context);\n\n      if (variables == null) {\n        return null;\n      }\n    }\n\n    else {\n      context.expect(GLSLX.TokenKind.SEMICOLON);\n    }\n\n    return GLSLX.Node.createStruct(symbol, block, variables);\n  };\n\n  GLSLX.Parser.checkForLoopAndSemicolon = function(context, range, node) {\n    var found = false;\n\n    for (var scope = context.scope(); scope != null; scope = scope.parent) {\n      if (scope.kind == GLSLX.ScopeKind.LOOP) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      context.log.syntaxErrorOutsideLoop(range);\n    }\n\n    return GLSLX.Parser.checkForSemicolon(context, range, node);\n  };\n\n  GLSLX.Parser.checkForSemicolon = function(context, range, node) {\n    context.expect(GLSLX.TokenKind.SEMICOLON);\n    return node.withRange(context.spanSince(range));\n  };\n\n  GLSLX.Parser.parseAfterType = function(context, range, flags, type, allow) {\n    var name = context.current().range;\n\n    if (flags == 0 && !context.peek(GLSLX.TokenKind.IDENTIFIER)) {\n      var value = GLSLX.Parser.pratt.resume(context, GLSLX.Precedence.LOWEST, type);\n\n      if (value == null) {\n        return null;\n      }\n\n      return GLSLX.Parser.checkForSemicolon(context, range, GLSLX.Node.createExpression(value));\n    }\n\n    if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n      return null;\n    }\n\n    if (context.eat(GLSLX.TokenKind.LEFT_PARENTHESIS)) {\n      return GLSLX.Parser.parseFunction(flags, type, name, context);\n    }\n\n    var variables = GLSLX.Parser.parseVariables(flags, type, name, context);\n\n    if (variables == null) {\n      return null;\n    }\n\n    return variables.withRange(context.spanSince(range));\n  };\n\n  GLSLX.Parser.parseStatement = function(context, mode) {\n    var token = context.current();\n\n    switch (token.kind) {\n      case GLSLX.TokenKind.BREAK: {\n        return GLSLX.Parser.checkForLoopAndSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.BREAK));\n      }\n\n      case GLSLX.TokenKind.CONTINUE: {\n        return GLSLX.Parser.checkForLoopAndSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.CONTINUE));\n      }\n\n      case GLSLX.TokenKind.DISCARD: {\n        return GLSLX.Parser.checkForSemicolon(context, context.next().range, new GLSLX.Node(GLSLX.NodeKind.DISCARD));\n      }\n\n      case GLSLX.TokenKind.DO: {\n        return GLSLX.Parser.parseDoWhile(context);\n      }\n\n      case GLSLX.TokenKind.EXPORT:\n      case GLSLX.TokenKind.IMPORT: {\n        return GLSLX.Parser.parseExportOrImport(context);\n      }\n\n      case GLSLX.TokenKind.EXTENSION: {\n        return GLSLX.Parser.parseExtension(context);\n      }\n\n      case GLSLX.TokenKind.FOR: {\n        return GLSLX.Parser.parseFor(context);\n      }\n\n      case GLSLX.TokenKind.IF: {\n        return GLSLX.Parser.parseIf(context);\n      }\n\n      case GLSLX.TokenKind.LEFT_BRACE: {\n        return GLSLX.Parser.parseBlock(context);\n      }\n\n      case GLSLX.TokenKind.PRECISION: {\n        return GLSLX.Parser.parsePrecision(context);\n      }\n\n      case GLSLX.TokenKind.RETURN: {\n        return GLSLX.Parser.parseReturn(context);\n      }\n\n      case GLSLX.TokenKind.SEMICOLON: {\n        return new GLSLX.Node(GLSLX.NodeKind.BLOCK).withRange(context.next().range);\n      }\n\n      case GLSLX.TokenKind.VERSION: {\n        return GLSLX.Parser.parseVersion(context);\n      }\n\n      case GLSLX.TokenKind.WHILE: {\n        return GLSLX.Parser.parseWhile(context);\n      }\n    }\n\n    // Try to parse a variable or function\n    var flags = GLSLX.Parser.parseFlags(context, mode);\n    var type = null;\n\n    if (context.eat(GLSLX.TokenKind.STRUCT)) {\n      var struct = GLSLX.Parser.parseStruct(context, flags);\n\n      if (struct == null) {\n        return null;\n      }\n\n      return struct.withRange(context.spanSince(token.range));\n    }\n\n    if (flags != 0) {\n      type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\n\n      if (type == null) {\n        return null;\n      }\n    }\n\n    else {\n      type = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.IGNORE_ERRORS);\n    }\n\n    if (type != null) {\n      return GLSLX.Parser.parseAfterType(context, token.range, flags, type, GLSLX.Parser.Allow.ALLOW_FUNCTIONS);\n    }\n\n    // Parse an expression\n    var value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n    if (value == null) {\n      return null;\n    }\n\n    return GLSLX.Parser.checkForSemicolon(context, token.range, GLSLX.Node.createExpression(value));\n  };\n\n  GLSLX.Parser.checkStatementLocation = function(context, node) {\n    if (node.kind == GLSLX.NodeKind.VARIABLES || node.kind == GLSLX.NodeKind.STRUCT) {\n      return;\n    }\n\n    var isOutsideFunction = context.scope().kind == GLSLX.ScopeKind.GLOBAL || context.scope().kind == GLSLX.ScopeKind.STRUCT;\n    var shouldBeOutsideFunction = node.kind == GLSLX.NodeKind.EXTENSION || node.kind == GLSLX.NodeKind.FUNCTION || node.kind == GLSLX.NodeKind.PRECISION || node.kind == GLSLX.NodeKind.VERSION;\n\n    if (shouldBeOutsideFunction && !isOutsideFunction) {\n      context.log.syntaxErrorInsideFunction(node.range);\n    }\n\n    else if (!shouldBeOutsideFunction && isOutsideFunction) {\n      context.log.syntaxErrorOutsideFunction(node.range);\n    }\n  };\n\n  GLSLX.Parser.parseInclude = function(context, parent) {\n    // See if there is a string literal\n    var range = context.current().range;\n\n    if (!context.expect(GLSLX.TokenKind.STRING_LITERAL)) {\n      return false;\n    }\n\n    // Decode the escapes\n    var path = null;\n\n    try {\n      path = JSON.parse(range.toString());\n    }\n\n    catch (e) {\n      context.log.syntaxErrorInvalidString(range);\n      return false;\n    }\n\n    // Must have access to the file system\n    var fileAccess = context.compilationData.fileAccess;\n\n    if (fileAccess == null) {\n      context.log.semanticErrorIncludeWithoutFileAccess(range);\n      return false;\n    }\n\n    // Must be able to read the file\n    var source = fileAccess(path, range.source.name);\n\n    if (source == null) {\n      context.log.semanticErrorIncludeBadPath(range, path);\n      return false;\n    }\n\n    // Parse the file and insert it into the parent\n    var tokens = GLSLX.Tokenizer.tokenize(context.log, source);\n    var nestedContext = new GLSLX.ParserContext(context.log, tokens, context.compilationData, context.resolver);\n    nestedContext.pushScope(context.scope());\n\n    if (!GLSLX.Parser.parseStatements(nestedContext, parent, GLSLX.VariableKind.GLOBAL) || !nestedContext.expect(GLSLX.TokenKind.END_OF_FILE)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  GLSLX.Parser.parseBlock = function(context) {\n    var token = context.current();\n    var block = new GLSLX.Node(GLSLX.NodeKind.BLOCK);\n    context.pushScope(new GLSLX.Scope(GLSLX.ScopeKind.LOCAL, context.scope()));\n\n    if (!context.expect(GLSLX.TokenKind.LEFT_BRACE) || !GLSLX.Parser.parseStatements(context, block, GLSLX.VariableKind.LOCAL) || !context.expect(GLSLX.TokenKind.RIGHT_BRACE)) {\n      return null;\n    }\n\n    context.popScope();\n    return block.withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseFlags = function(context, mode) {\n    var flags = 0;\n\n    while (true) {\n      var kind = context.current().kind;\n\n      switch (kind) {\n        case GLSLX.TokenKind.ATTRIBUTE: {\n          flags |= GLSLX.SymbolFlags.ATTRIBUTE;\n          break;\n        }\n\n        case GLSLX.TokenKind.CONST: {\n          flags |= GLSLX.SymbolFlags.CONST;\n          break;\n        }\n\n        case GLSLX.TokenKind.HIGHP: {\n          flags |= GLSLX.SymbolFlags.HIGHP;\n          break;\n        }\n\n        case GLSLX.TokenKind.IN: {\n          flags |= GLSLX.SymbolFlags.IN;\n          break;\n        }\n\n        case GLSLX.TokenKind.INOUT: {\n          flags |= GLSLX.SymbolFlags.INOUT;\n          break;\n        }\n\n        case GLSLX.TokenKind.LOWP: {\n          flags |= GLSLX.SymbolFlags.LOWP;\n          break;\n        }\n\n        case GLSLX.TokenKind.MEDIUMP: {\n          flags |= GLSLX.SymbolFlags.MEDIUMP;\n          break;\n        }\n\n        case GLSLX.TokenKind.OUT: {\n          flags |= GLSLX.SymbolFlags.OUT;\n          break;\n        }\n\n        case GLSLX.TokenKind.UNIFORM: {\n          flags |= GLSLX.SymbolFlags.UNIFORM;\n          break;\n        }\n\n        case GLSLX.TokenKind.VARYING: {\n          flags |= GLSLX.SymbolFlags.VARYING;\n          break;\n        }\n\n        default: {\n          return flags;\n        }\n      }\n\n      if (mode == GLSLX.VariableKind.ARGUMENT && (kind == GLSLX.TokenKind.ATTRIBUTE || kind == GLSLX.TokenKind.UNIFORM || kind == GLSLX.TokenKind.VARYING) || mode == GLSLX.VariableKind.STRUCT && kind != GLSLX.TokenKind.LOWP && kind != GLSLX.TokenKind.MEDIUMP && kind != GLSLX.TokenKind.HIGHP || mode != GLSLX.VariableKind.ARGUMENT && (kind == GLSLX.TokenKind.IN || kind == GLSLX.TokenKind.OUT || kind == GLSLX.TokenKind.INOUT)) {\n        context.log.syntaxErrorBadQualifier(context.current().range);\n      }\n\n      context.next();\n    }\n  };\n\n  GLSLX.Parser.parseType = function(context, mode) {\n    var token = context.current();\n    var type = null;\n\n    switch (token.kind) {\n      case GLSLX.TokenKind.BOOL: {\n        type = GLSLX.Type.BOOL;\n        break;\n      }\n\n      case GLSLX.TokenKind.BVEC2: {\n        type = GLSLX.Type.BVEC2;\n        break;\n      }\n\n      case GLSLX.TokenKind.BVEC3: {\n        type = GLSLX.Type.BVEC3;\n        break;\n      }\n\n      case GLSLX.TokenKind.BVEC4: {\n        type = GLSLX.Type.BVEC4;\n        break;\n      }\n\n      case GLSLX.TokenKind.FLOAT: {\n        type = GLSLX.Type.FLOAT;\n        break;\n      }\n\n      case GLSLX.TokenKind.INT: {\n        type = GLSLX.Type.INT;\n        break;\n      }\n\n      case GLSLX.TokenKind.IVEC2: {\n        type = GLSLX.Type.IVEC2;\n        break;\n      }\n\n      case GLSLX.TokenKind.IVEC3: {\n        type = GLSLX.Type.IVEC3;\n        break;\n      }\n\n      case GLSLX.TokenKind.IVEC4: {\n        type = GLSLX.Type.IVEC4;\n        break;\n      }\n\n      case GLSLX.TokenKind.MAT2: {\n        type = GLSLX.Type.MAT2;\n        break;\n      }\n\n      case GLSLX.TokenKind.MAT3: {\n        type = GLSLX.Type.MAT3;\n        break;\n      }\n\n      case GLSLX.TokenKind.MAT4: {\n        type = GLSLX.Type.MAT4;\n        break;\n      }\n\n      case GLSLX.TokenKind.SAMPLER2D: {\n        type = GLSLX.Type.SAMPLER2D;\n        break;\n      }\n\n      case GLSLX.TokenKind.SAMPLERCUBE: {\n        type = GLSLX.Type.SAMPLERCUBE;\n        break;\n      }\n\n      case GLSLX.TokenKind.VEC2: {\n        type = GLSLX.Type.VEC2;\n        break;\n      }\n\n      case GLSLX.TokenKind.VEC3: {\n        type = GLSLX.Type.VEC3;\n        break;\n      }\n\n      case GLSLX.TokenKind.VEC4: {\n        type = GLSLX.Type.VEC4;\n        break;\n      }\n\n      case GLSLX.TokenKind.VOID: {\n        type = GLSLX.Type.VOID;\n        break;\n      }\n\n      case GLSLX.TokenKind.IDENTIFIER: {\n        var symbol = context.scope().find(token.range.toString());\n\n        if (symbol == null || !symbol.isStruct()) {\n          if (mode == GLSLX.Parser.ParseTypeMode.REPORT_ERRORS) {\n            context.unexpectedToken();\n          }\n\n          return null;\n        }\n\n        type = symbol.resolvedType();\n        break;\n      }\n\n      default: {\n        if (mode == GLSLX.Parser.ParseTypeMode.REPORT_ERRORS) {\n          context.unexpectedToken();\n        }\n\n        return null;\n      }\n    }\n\n    context.next();\n    return new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(type).withRange(context.spanSince(token.range));\n  };\n\n  GLSLX.Parser.parseFunction = function(flags, type, name, context) {\n    var originalScope = context.scope();\n    var $function = new GLSLX.FunctionSymbol(context.compilationData.nextSymbolID(), name, name.toString(), new GLSLX.Scope(GLSLX.ScopeKind.FUNCTION, originalScope));\n    $function.flags |= context.flags | flags | ($function.name == 'main' ? GLSLX.SymbolFlags.EXPORTED : 0);\n    $function.returnType = type;\n    context.pushScope($function.scope);\n\n    // Takes no arguments\n    if (context.eat(GLSLX.TokenKind.VOID)) {\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n    }\n\n    // Takes arguments\n    else if (!context.eat(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n      while (true) {\n        // Parse leading flags\n        var argumentFlags = GLSLX.Parser.parseFlags(context, GLSLX.VariableKind.ARGUMENT);\n\n        // Parse the type\n        var argumentType = GLSLX.Parser.parseType(context, GLSLX.Parser.ParseTypeMode.REPORT_ERRORS);\n\n        if (argumentType == null) {\n          return null;\n        }\n\n        // Parse the identifier\n        var argumentName = context.current().range;\n\n        if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n          return null;\n        }\n\n        // Create the argument\n        var argument = new GLSLX.VariableSymbol(context.compilationData.nextSymbolID(), argumentName, argumentName.toString(), context.scope(), GLSLX.VariableKind.ARGUMENT);\n        argument.flags |= argumentFlags;\n        argument.type = argumentType;\n        $function.$arguments.push(argument);\n        GLSLX.Parser.tryToDefineUniquelyInScope(context, argument);\n\n        // Array size\n        if (!GLSLX.Parser.parseArraySize(context, argument)) {\n          return null;\n        }\n\n        // Parse another argument?\n        if (!context.eat(GLSLX.TokenKind.COMMA)) {\n          break;\n        }\n      }\n\n      if (!context.expect(GLSLX.TokenKind.RIGHT_PARENTHESIS)) {\n        return null;\n      }\n    }\n\n    var previous = in_StringMap.get(originalScope.symbols, name.toString(), null);\n    var hasBlock = !context.eat(GLSLX.TokenKind.SEMICOLON);\n\n    // Merge adjacent function symbols to support overloading\n    if (previous == null) {\n      originalScope.define($function);\n    }\n\n    else if (previous.isFunction()) {\n      for (var link = previous.asFunction(); link != null; link = link.previousOverload) {\n        if (!link.hasSameArgumentTypesAs($function)) {\n          continue;\n        }\n\n        // Overloading by return type is not allowed\n        if (link.returnType.resolvedType != $function.returnType.resolvedType) {\n          context.log.syntaxErrorDifferentReturnType($function.returnType.range, $function.name, $function.returnType.resolvedType, link.returnType.resolvedType, link.returnType.range);\n        }\n\n        // Defining a function more than once is not allowed\n        else if (link.block != null || !hasBlock) {\n          context.log.syntaxErrorDuplicateSymbolDefinition($function.range, link.range);\n        }\n\n        // Merge the function with its forward declaration\n        else {\n          assert(link.sibling == null);\n          assert($function.sibling == null);\n          link.sibling = $function;\n          $function.sibling = link;\n          $function.flags |= link.flags;\n          link.flags = $function.flags;\n        }\n\n        break;\n      }\n\n      // Use a singly-linked list to store the function overloads\n      $function.previousOverload = previous.asFunction();\n      originalScope.redefine($function);\n    }\n\n    else {\n      context.log.syntaxErrorDuplicateSymbolDefinition(name, previous.range);\n      return null;\n    }\n\n    if (hasBlock) {\n      var old = context.flags;\n      context.flags &= ~(GLSLX.SymbolFlags.EXPORTED | GLSLX.SymbolFlags.IMPORTED);\n      $function.block = GLSLX.Parser.parseBlock(context);\n      context.flags &= old;\n\n      if ($function.block == null) {\n        return null;\n      }\n    }\n\n    context.popScope();\n    return new GLSLX.Node(GLSLX.NodeKind.FUNCTION).withSymbol($function).withRange(context.spanSince(type.range));\n  };\n\n  GLSLX.Parser.parseArraySize = function(context, variable) {\n    var token = context.current();\n\n    if (context.eat(GLSLX.TokenKind.LEFT_BRACKET)) {\n      // The \"[]\" syntax isn't valid but skip over it and recover\n      if (context.eat(GLSLX.TokenKind.RIGHT_BRACKET)) {\n        context.log.syntaxErrorMissingArraySize(context.spanSince(token.range));\n        return true;\n      }\n\n      variable.arrayCount = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST);\n\n      if (variable.arrayCount == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\n        return false;\n      }\n\n      // The array size must be resolved immediately\n      var count = 0;\n      context.resolver.resolveNode(variable.arrayCount);\n      context.resolver.checkConversion(variable.arrayCount, GLSLX.Type.INT);\n\n      if (variable.arrayCount.resolvedType != GLSLX.Type.ERROR) {\n        var folded = GLSLX.Folder.fold(variable.arrayCount);\n\n        if (folded == null) {\n          context.log.syntaxErrorConstantRequired(variable.arrayCount.range);\n        }\n\n        else if (folded.kind == GLSLX.NodeKind.INT) {\n          var value = folded.asInt();\n\n          if (value < 1) {\n            context.log.syntaxErrorInvalidArraySize(variable.arrayCount.range, value);\n          }\n\n          else {\n            count = value;\n          }\n        }\n      }\n\n      // Multidimensional arrays are not supported\n      while (context.peek(GLSLX.TokenKind.LEFT_BRACKET)) {\n        token = context.next();\n\n        if (!context.peek(GLSLX.TokenKind.RIGHT_BRACKET) && GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.LOWEST) == null || !context.expect(GLSLX.TokenKind.RIGHT_BRACKET)) {\n          return false;\n        }\n\n        context.log.syntaxErrorMultidimensionalArray(context.spanSince(token.range));\n      }\n\n      variable.type = new GLSLX.Node(GLSLX.NodeKind.TYPE).withType(variable.type.resolvedType.arrayType(count)).withRange(variable.type.range);\n    }\n\n    return true;\n  };\n\n  GLSLX.Parser.parseVariables = function(flags, type, name, context) {\n    var variables = GLSLX.Node.createVariables(context.flags | flags, type);\n\n    while (true) {\n      var symbol = new GLSLX.VariableSymbol(context.compilationData.nextSymbolID(), name, name.toString(), context.scope(), context.scope().kind == GLSLX.ScopeKind.GLOBAL ? GLSLX.VariableKind.GLOBAL : context.scope().kind == GLSLX.ScopeKind.STRUCT ? GLSLX.VariableKind.STRUCT : GLSLX.VariableKind.LOCAL);\n      symbol.flags |= context.flags | flags;\n      symbol.type = type;\n\n      // Array size\n      if (!GLSLX.Parser.parseArraySize(context, symbol)) {\n        return null;\n      }\n\n      // Initial value\n      var assign = context.current().range;\n\n      if (context.eat(GLSLX.TokenKind.ASSIGN)) {\n        symbol.value = GLSLX.Parser.pratt.parse(context, GLSLX.Precedence.COMMA);\n\n        if (symbol.value == null) {\n          return null;\n        }\n      }\n\n      else {\n        assign = null;\n      }\n\n      // Constants must be resolved immediately\n      var variable = new GLSLX.Node(GLSLX.NodeKind.VARIABLE).withSymbol(symbol).withRange(context.spanSince(symbol.range)).withInternalRange(assign);\n\n      if (symbol.isConst()) {\n        context.resolver.resolveNode(variable);\n      }\n\n      variables.appendChild(variable);\n      GLSLX.Parser.tryToDefineUniquelyInScope(context, symbol);\n\n      // Are there more variables in this statement?\n      if (!context.eat(GLSLX.TokenKind.COMMA)) {\n        context.expect(GLSLX.TokenKind.SEMICOLON);\n        return variables;\n      }\n\n      name = context.current().range;\n\n      if (!context.expect(GLSLX.TokenKind.IDENTIFIER)) {\n        return null;\n      }\n    }\n  };\n\n  GLSLX.Parser.tryToDefineUniquelyInScope = function(context, symbol) {\n    var previous = in_StringMap.get(context.scope().symbols, symbol.name, null);\n\n    if (previous != null) {\n      context.log.syntaxErrorDuplicateSymbolDefinition(symbol.range, previous.range);\n      return false;\n    }\n\n    context.scope().define(symbol);\n    return true;\n  };\n\n  GLSLX.Parser.parseStatements = function(context, parent, mode) {\n    while (!context.peek(GLSLX.TokenKind.END_OF_FILE) && !context.peek(GLSLX.TokenKind.RIGHT_BRACE)) {\n      if (context.eat(GLSLX.TokenKind.INCLUDE)) {\n        if (!GLSLX.Parser.parseInclude(context, parent)) {\n          return false;\n        }\n\n        continue;\n      }\n\n      var statement = GLSLX.Parser.parseStatement(context, mode);\n\n      if (statement == null) {\n        return false;\n      }\n\n      // Extension blocks are temporary and don't exist in the parsed result\n      if (statement.kind == GLSLX.NodeKind.MODIFIER_BLOCK) {\n        while (statement.hasChildren()) {\n          var child = statement.firstChild().remove();\n          GLSLX.Parser.checkStatementLocation(context, child);\n          parent.appendChild(child);\n        }\n      }\n\n      else {\n        GLSLX.Parser.checkStatementLocation(context, statement);\n        parent.appendChild(statement);\n      }\n    }\n\n    return true;\n  };\n\n  GLSLX.Parser.parse = function(log, tokens, global, data, scope, resolver) {\n    if (GLSLX.Parser.pratt == null) {\n      GLSLX.Parser.pratt = GLSLX.Parser.createExpressionParser();\n    }\n\n    var context = new GLSLX.ParserContext(log, tokens, data, resolver);\n    context.pushScope(scope);\n\n    if (GLSLX.Parser.parseStatements(context, global, GLSLX.VariableKind.GLOBAL)) {\n      context.expect(GLSLX.TokenKind.END_OF_FILE);\n    }\n  };\n\n  GLSLX.Parser.Allow = {\n    AVOID_FUNCTIONS: 0,\n    ALLOW_FUNCTIONS: 1\n  };\n\n  GLSLX.Parser.ParseTypeMode = {\n    IGNORE_ERRORS: 0,\n    REPORT_ERRORS: 1\n  };\n\n  // The same operator precedence as C for the most part\n  GLSLX.Precedence = {\n    LOWEST: 0,\n    COMMA: 1,\n    ASSIGN: 2,\n    LOGICAL_OR: 3,\n    LOGICAL_XOR: 4,\n    LOGICAL_AND: 5,\n    BITWISE_OR: 6,\n    BITWISE_XOR: 7,\n    BITWISE_AND: 8,\n    COMPARE: 10,\n    SHIFT: 11,\n    ADD: 12,\n    MULTIPLY: 13,\n    UNARY_PREFIX: 14,\n    UNARY_POSTFIX: 15,\n    MEMBER: 16\n  };\n\n  GLSLX.ParserContext = function(log, _tokens, compilationData, resolver) {\n    this.log = log;\n    this._tokens = _tokens;\n    this.compilationData = compilationData;\n    this.resolver = resolver;\n    this.flags = 0;\n    this._index = 0;\n    this._scope = null;\n  };\n\n  GLSLX.ParserContext.prototype.current = function() {\n    return in_List.get(this._tokens, this._index);\n  };\n\n  GLSLX.ParserContext.prototype.next = function() {\n    var token = this.current();\n\n    if ((this._index + 1 | 0) < this._tokens.length) {\n      this._index = this._index + 1 | 0;\n    }\n\n    return token;\n  };\n\n  GLSLX.ParserContext.prototype.spanSince = function(range) {\n    var previous = in_List.get(this._tokens, this._index > 0 ? this._index - 1 | 0 : 0);\n    return previous.range.end < range.start ? range : GLSLX.Range.span(range, previous.range);\n  };\n\n  GLSLX.ParserContext.prototype.peek = function(kind) {\n    return this.current().kind == kind;\n  };\n\n  GLSLX.ParserContext.prototype.eat = function(kind) {\n    if (this.peek(kind)) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  };\n\n  GLSLX.ParserContext.prototype.expect = function(kind) {\n    if (this.eat(kind)) {\n      return true;\n    }\n\n    var token = this.current();\n    var range = token.range;\n    var previous = (this._index > 0 ? in_List.get(this._tokens, this._index - 1 | 0) : token).range;\n\n    // Put errors about missing semicolons and about tokens on the next line\n    // after the previous token instead of at the next token\n    if (kind == GLSLX.TokenKind.SEMICOLON || previous.lineColumn().line != range.lineColumn().line) {\n      this.log.syntaxErrorExpectedToken1(previous.rangeAtEnd(), kind);\n    }\n\n    else {\n      this.log.syntaxErrorExpectedToken2(range, token.kind, kind);\n    }\n\n    return false;\n  };\n\n  GLSLX.ParserContext.prototype.unexpectedToken = function() {\n    this.log.syntaxErrorUnexpectedToken(this.current());\n  };\n\n  GLSLX.ParserContext.prototype.scope = function() {\n    return this._scope;\n  };\n\n  GLSLX.ParserContext.prototype.pushScope = function(newScope) {\n    assert(newScope.parent == this._scope);\n    this._scope = newScope;\n  };\n\n  GLSLX.ParserContext.prototype.popScope = function() {\n    assert(this._scope != null);\n    this._scope = this._scope.parent;\n  };\n\n  GLSLX.Parselet = function(precedence) {\n    this.precedence = precedence;\n    this.prefix = null;\n    this.infix = null;\n  };\n\n  // A Pratt parser is a parser that associates up to two operations per token,\n  // each with its own precedence. Pratt parsers excel at parsing expression\n  // trees with deeply nested precedence levels. For an excellent writeup, see:\n  //\n  //   http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/\n  //\n  GLSLX.Pratt = function() {\n    this._table = {};\n  };\n\n  GLSLX.Pratt.prototype.parselet = function(kind, precedence) {\n    var parselet = in_IntMap.get(this._table, kind, null);\n\n    if (parselet == null) {\n      var created = new GLSLX.Parselet(precedence);\n      parselet = created;\n      this._table[kind] = created;\n    }\n\n    else if (precedence > parselet.precedence) {\n      parselet.precedence = precedence;\n    }\n\n    return parselet;\n  };\n\n  GLSLX.Pratt.prototype.parse = function(context, precedence) {\n    var token = context.current();\n    var parselet = in_IntMap.get(this._table, token.kind, null);\n\n    if (parselet == null || parselet.prefix == null) {\n      context.unexpectedToken();\n      return null;\n    }\n\n    var node = this.resume(context, precedence, parselet.prefix(context));\n\n    // Parselets must set the range of every node\n    assert(node == null || node.range != null);\n    return node;\n  };\n\n  GLSLX.Pratt.prototype.resume = function(context, precedence, left) {\n    while (left != null) {\n      var kind = context.current().kind;\n      var parselet = in_IntMap.get(this._table, kind, null);\n\n      if (parselet == null || parselet.infix == null || parselet.precedence <= precedence) {\n        break;\n      }\n\n      left = parselet.infix(context, left);\n\n      // Parselets must set the range of every node\n      assert(left == null || left.range != null);\n    }\n\n    return left;\n  };\n\n  GLSLX.Pratt.prototype.literal = function(kind, callback) {\n    this.parselet(kind, GLSLX.Precedence.LOWEST).prefix = function(context) {\n      return callback(context, context.next());\n    };\n  };\n\n  GLSLX.Pratt.prototype.prefix = function(kind, precedence, callback) {\n    var self = this;\n    self.parselet(kind, GLSLX.Precedence.LOWEST).prefix = function(context) {\n      var token = context.next();\n      var value = self.parse(context, precedence);\n      return value != null ? callback(context, token, value) : null;\n    };\n  };\n\n  GLSLX.Pratt.prototype.postfix = function(kind, precedence, callback) {\n    this.parselet(kind, precedence).infix = function(context, left) {\n      return callback(context, left, context.next());\n    };\n  };\n\n  GLSLX.Pratt.prototype.infix = function(kind, precedence, callback) {\n    var self = this;\n    self.parselet(kind, precedence).infix = function(context, left) {\n      var token = context.next();\n      var right = self.parse(context, precedence);\n      return right != null ? callback(context, left, token, right) : null;\n    };\n  };\n\n  GLSLX.Pratt.prototype.infixRight = function(kind, precedence, callback) {\n    var self = this;\n    self.parselet(kind, precedence).infix = function(context, left) {\n      var token = context.next();\n\n      // Subtract 1 for right-associativity\n      var right = self.parse(context, precedence - 1 | 0);\n      return right != null ? callback(context, left, token, right) : null;\n    };\n  };\n\n  GLSLX.Range = function(source, start, end) {\n    this.source = source;\n    this.start = start;\n    this.end = end;\n  };\n\n  GLSLX.Range.prototype.toString = function() {\n    return in_string.slice2(this.source.contents, this.start, this.end);\n  };\n\n  GLSLX.Range.prototype.slice = function(offsetStart, offsetEnd) {\n    assert(offsetStart >= 0 && offsetStart <= offsetEnd && offsetEnd <= (this.end - this.start | 0));\n    return new GLSLX.Range(this.source, this.start + offsetStart | 0, this.start + offsetEnd | 0);\n  };\n\n  GLSLX.Range.prototype.lineColumn = function() {\n    return this.source.indexToLineColumn(this.start);\n  };\n\n  GLSLX.Range.prototype.rangeAtEnd = function() {\n    return new GLSLX.Range(this.source, this.end, this.end);\n  };\n\n  GLSLX.Range.span = function(start, end) {\n    assert(start.source == end.source);\n    assert(start.start <= end.end);\n    return new GLSLX.Range(start.source, start.start, end.end);\n  };\n\n  GLSLX.Resolver = function(_log, _data) {\n    this._log = _log;\n    this._data = _data;\n    this._controlFlow = new GLSLX.ControlFlowAnalyzer();\n    this._versions = [];\n    this._generatedExtensions = Object.create(null);\n    this._returnType = null;\n  };\n\n  GLSLX.Resolver.prototype.resolveGlobal = function(global) {\n    this.resolveNode(global);\n\n    // Remove all version statements\n    for (var i = 0, list = this._versions, count = list.length; i < count; i = i + 1 | 0) {\n      var version = in_List.get(list, i);\n      version.remove();\n    }\n\n    // Re-insert the first version statement\n    var first = global.firstChild();\n\n    if (!(this._versions.length == 0)) {\n      global.insertChildBefore(first, in_List.first(this._versions));\n    }\n\n    // Insert all automatically generated extensions\n    for (var i1 = 0, list1 = in_StringMap.values(this._generatedExtensions), count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\n      var extension = in_List.get(list1, i1);\n      global.insertChildBefore(first, extension);\n    }\n  };\n\n  GLSLX.Resolver.prototype.resolveNode = function(node) {\n    if (node.resolvedType != null) {\n      return;\n    }\n\n    node.resolvedType = GLSLX.Type.ERROR;\n    var kind = node.kind;\n\n    switch (kind) {\n      case GLSLX.NodeKind.GLOBAL:\n      case GLSLX.NodeKind.STRUCT_BLOCK: {\n        this._resolveChildren(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.VARIABLE: {\n        var symbol = node.symbol.asVariable();\n        this.resolveNode(symbol.type);\n\n        // Variables must have a type\n        var type = symbol.type.resolvedType;\n\n        if (type == GLSLX.Type.VOID) {\n          this._log.semanticErrorBadVariableType(symbol.type.range, type);\n          type = GLSLX.Type.ERROR;\n        }\n\n        // Array size\n        if (symbol.arrayCount != null) {\n          this._resolveAsExpression(symbol.arrayCount);\n          this.checkConversion(symbol.arrayCount, GLSLX.Type.INT);\n        }\n\n        // Initial value\n        if (symbol.value != null) {\n          this._resolveAsExpression(symbol.value);\n          this.checkConversion(symbol.value, type);\n\n          if (type.containsArray) {\n            this._log.semanticErrorArrayAssignment(node.internalRange, type);\n          }\n        }\n\n        // Constants must be initialized\n        if (symbol.isConst()) {\n          if (symbol.value != null) {\n            if (symbol.value.resolvedType != GLSLX.Type.ERROR) {\n              var folded = GLSLX.Folder.fold(symbol.value);\n\n              if (folded == null) {\n                this._log.syntaxErrorConstantRequired(symbol.value.range);\n              }\n\n              else {\n                assert(folded.parent() == null);\n                assert(folded.resolvedType != null);\n                symbol.constantValue = folded;\n              }\n            }\n          }\n\n          else if (symbol.kind == GLSLX.VariableKind.LOCAL) {\n            this._log.semanticErrorUninitializedConstant(symbol.range);\n          }\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.BLOCK: {\n        this._resolveBlockOrStatement(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.BREAK:\n      case GLSLX.NodeKind.CONTINUE:\n      case GLSLX.NodeKind.DISCARD: {\n        break;\n      }\n\n      case GLSLX.NodeKind.DO_WHILE: {\n        this._resolveBlockOrStatement(node.doWhileBody());\n        this.resolveNode(node.doWhileTest());\n        this.checkConversion(node.doWhileTest(), GLSLX.Type.BOOL);\n        break;\n      }\n\n      case GLSLX.NodeKind.EXPRESSION: {\n        this.resolveNode(node.expressionValue());\n        break;\n      }\n\n      case GLSLX.NodeKind.EXTENSION: {\n        break;\n      }\n\n      case GLSLX.NodeKind.FOR: {\n        if (node.forSetup() != null) {\n          this._resolveAsExpression(node.forSetup());\n        }\n\n        if (node.forTest() != null) {\n          this._resolveAsExpression(node.forTest());\n          this.checkConversion(node.forTest(), GLSLX.Type.BOOL);\n        }\n\n        if (node.forUpdate() != null) {\n          this._resolveAsExpression(node.forUpdate());\n        }\n\n        this._resolveBlockOrStatement(node.forBody());\n        break;\n      }\n\n      case GLSLX.NodeKind.FUNCTION: {\n        var symbol1 = node.symbol.asFunction();\n\n        for (var i = 0, list = symbol1.$arguments, count = list.length; i < count; i = i + 1 | 0) {\n          var argument = in_List.get(list, i);\n          this.resolveNode(argument.type);\n        }\n\n        this.resolveNode(symbol1.returnType);\n\n        if (symbol1.block != null) {\n          this._returnType = symbol1.returnType.resolvedType;\n          this._resolveBlockOrStatement(symbol1.block);\n\n          // Missing a return statement is an error\n          if (this._returnType != GLSLX.Type.VOID && symbol1.block.hasControlFlowAtEnd) {\n            this._log.semanticErrorMissingReturn(symbol1.range, symbol1.name, this._returnType);\n          }\n\n          this._returnType = null;\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.IF: {\n        this.resolveNode(node.ifTest());\n        this.checkConversion(node.ifTest(), GLSLX.Type.BOOL);\n        this._resolveBlockOrStatement(node.ifTrue());\n\n        if (node.ifFalse() != null) {\n          this._resolveBlockOrStatement(node.ifFalse());\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.PRECISION: {\n        break;\n      }\n\n      case GLSLX.NodeKind.RETURN: {\n        if (node.returnValue() != null) {\n          this.resolveNode(node.returnValue());\n          this.checkConversion(node.returnValue(), this._returnType != null ? this._returnType : GLSLX.Type.ERROR);\n        }\n\n        else {\n          node.resolvedType = GLSLX.Type.VOID;\n          this.checkConversion(node, this._returnType != null ? this._returnType : GLSLX.Type.ERROR);\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.STRUCT: {\n        this._resolveChildren(node);\n\n        // A struct loses operator \"==\" and \"!=\" when it contains a type without those operators\n        var resolvedType = node.symbol.resolvedType();\n\n        for (var i1 = 0, list1 = node.symbol.asStruct().variables, count1 = list1.length; i1 < count1; i1 = i1 + 1 | 0) {\n          var variable = in_List.get(list1, i1);\n          var type1 = variable.type.resolvedType;\n\n          if (type1.containsArray) {\n            resolvedType.containsArray = true;\n          }\n\n          if (type1.containsSampler) {\n            resolvedType.containsSampler = true;\n          }\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.VARIABLES: {\n        this._resolveChildren(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.VERSION: {\n        this._versions.push(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.WHILE: {\n        this.resolveNode(node.whileTest());\n        this.checkConversion(node.whileTest(), GLSLX.Type.BOOL);\n        this._resolveBlockOrStatement(node.whileBody());\n        break;\n      }\n\n      case GLSLX.NodeKind.CALL: {\n        this._resolveCall(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.DOT: {\n        this._resolveDot(node);\n        break;\n      }\n\n      case GLSLX.NodeKind.HOOK: {\n        var test = node.hookTest();\n        var no = node.hookFalse();\n        var yes = node.hookTrue();\n        this._resolveAsExpression(test);\n        this.checkConversion(test, GLSLX.Type.BOOL);\n        this._resolveAsExpression(yes);\n        this._resolveAsExpression(no);\n\n        if (yes.resolvedType != no.resolvedType) {\n          this._log.semanticErrorBadHookTypes(GLSLX.Range.span(yes.range, no.range), yes.resolvedType, no.resolvedType);\n        }\n\n        else if (yes.resolvedType.containsArray) {\n          this._log.semanticErrorArrayHook(GLSLX.Range.span(yes.range, no.range), yes.resolvedType);\n        }\n\n        else {\n          node.resolvedType = yes.resolvedType;\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.NAME: {\n        var symbol2 = node.symbol;\n\n        if (symbol2.isVariable()) {\n          this.resolveNode(symbol2.asVariable().type);\n          node.resolvedType = symbol2.asVariable().type.resolvedType;\n        }\n\n        else if (symbol2.isFunction() && !node.isCallTarget()) {\n          this._log.semanticErrorMustCallFunction(node.range, symbol2.name);\n        }\n\n        else {\n          node.resolvedType = symbol2.resolvedType();\n        }\n\n        // Make sure the extension is enabled if it hasn't been specified\n        var name = symbol2.requiredExtension;\n\n        if (name != null && !(name in this._generatedExtensions) && this._data.extensionBehavior(name) == GLSLX.ExtensionBehavior.DEFAULT) {\n          this._generatedExtensions[name] = new GLSLX.Node(GLSLX.NodeKind.EXTENSION).withText(name).withInt(GLSLX.ExtensionBehavior.ENABLE);\n        }\n        break;\n      }\n\n      case GLSLX.NodeKind.SEQUENCE: {\n        for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\n          this._resolveAsExpression(child);\n        }\n\n        node.resolvedType = node.lastChild().resolvedType;\n        break;\n      }\n\n      default: {\n        if (GLSLX.in_NodeKind.isUnary(kind)) {\n          this._resolveUnary(node);\n        }\n\n        else if (GLSLX.in_NodeKind.isBinary(kind)) {\n          this._resolveBinary(node);\n        }\n\n        else {\n          assert(false);\n        }\n        break;\n      }\n    }\n\n    assert(node.resolvedType != null);\n  };\n\n  GLSLX.Resolver.prototype._resolveBlockOrStatement = function(node) {\n    assert(GLSLX.in_NodeKind.isStatement(node.kind));\n    this._controlFlow.pushBlock(node);\n\n    if (node.kind == GLSLX.NodeKind.BLOCK) {\n      for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\n        this.resolveNode(child);\n        this._controlFlow.visitStatement(child);\n      }\n    }\n\n    else {\n      this.resolveNode(node);\n      this._controlFlow.visitStatement(node);\n    }\n\n    this._controlFlow.popBlock(node);\n  };\n\n  GLSLX.Resolver.prototype._resolveUnary = function(node) {\n    var value = node.unaryValue();\n    this._resolveAsExpression(value);\n\n    if (GLSLX.in_NodeKind.isUnaryAssign(node.kind)) {\n      this._checkStorage(value);\n    }\n\n    var valueType = value.resolvedType;\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.NEGATIVE:\n      case GLSLX.NodeKind.POSITIVE:\n      case GLSLX.NodeKind.PREFIX_DECREMENT:\n      case GLSLX.NodeKind.PREFIX_INCREMENT:\n      case GLSLX.NodeKind.POSTFIX_DECREMENT:\n      case GLSLX.NodeKind.POSTFIX_INCREMENT: {\n        node.resolvedType = valueType.isIntOrFloat() ? valueType : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.NOT: {\n        node.resolvedType = valueType == GLSLX.Type.BOOL ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\n        break;\n      }\n    }\n\n    if (node.resolvedType == GLSLX.Type.ERROR && valueType != GLSLX.Type.ERROR) {\n      this._log.semanticErrorBadUnaryOperator(node.internalRange, node.internalRange.toString(), valueType);\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveBinary = function(node) {\n    var left = node.binaryLeft();\n    var right = node.binaryRight();\n    this._resolveAsExpression(left);\n    this._resolveAsExpression(right);\n\n    if (GLSLX.in_NodeKind.isBinaryAssign(node.kind)) {\n      this._checkStorage(left);\n    }\n\n    var leftType = left.resolvedType;\n    var rightType = right.resolvedType;\n    var isSame = leftType == rightType;\n\n    switch (node.kind) {\n      case GLSLX.NodeKind.ADD:\n      case GLSLX.NodeKind.SUBTRACT:\n      case GLSLX.NodeKind.MULTIPLY:\n      case GLSLX.NodeKind.DIVIDE: {\n        node.resolvedType = isSame && leftType.componentType() != null ? leftType : leftType.hasFloatComponents() && rightType == GLSLX.Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType == GLSLX.Type.INT ? leftType : leftType == GLSLX.Type.FLOAT && rightType.hasFloatComponents() ? rightType : leftType == GLSLX.Type.INT && rightType.hasIntComponents() ? rightType : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.MAT2 && rightType == GLSLX.Type.VEC2) ? GLSLX.Type.VEC2 : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.MAT3 && rightType == GLSLX.Type.VEC3) ? GLSLX.Type.VEC3 : node.kind == GLSLX.NodeKind.MULTIPLY && (leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4 || leftType == GLSLX.Type.MAT4 && rightType == GLSLX.Type.VEC4) ? GLSLX.Type.VEC4 : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.EQUAL:\n      case GLSLX.NodeKind.NOT_EQUAL: {\n        node.resolvedType = isSame && leftType.canUseEqualityOperators() ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.LOGICAL_AND:\n      case GLSLX.NodeKind.LOGICAL_OR:\n      case GLSLX.NodeKind.LOGICAL_XOR: {\n        node.resolvedType = isSame && leftType == GLSLX.Type.BOOL ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.LESS_THAN:\n      case GLSLX.NodeKind.LESS_THAN_OR_EQUAL:\n      case GLSLX.NodeKind.GREATER_THAN:\n      case GLSLX.NodeKind.GREATER_THAN_OR_EQUAL: {\n        node.resolvedType = isSame && (leftType == GLSLX.Type.FLOAT || leftType == GLSLX.Type.INT) ? GLSLX.Type.BOOL : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.ASSIGN: {\n        node.resolvedType = leftType;\n\n        if (leftType.containsArray) {\n          this._log.semanticErrorArrayAssignment(node.internalRange, leftType);\n        }\n\n        this.checkConversion(right, leftType);\n        return;\n      }\n\n      case GLSLX.NodeKind.ASSIGN_ADD:\n      case GLSLX.NodeKind.ASSIGN_SUBTRACT:\n      case GLSLX.NodeKind.ASSIGN_MULTIPLY:\n      case GLSLX.NodeKind.ASSIGN_DIVIDE: {\n        node.resolvedType = isSame && leftType.componentType() != null ? leftType : leftType.hasFloatComponents() && rightType == GLSLX.Type.FLOAT ? leftType : leftType.hasIntComponents() && rightType == GLSLX.Type.INT ? leftType : node.kind == GLSLX.NodeKind.ASSIGN_MULTIPLY && (leftType == GLSLX.Type.VEC2 && rightType == GLSLX.Type.MAT2 || leftType == GLSLX.Type.VEC3 && rightType == GLSLX.Type.MAT3 || leftType == GLSLX.Type.VEC4 && rightType == GLSLX.Type.MAT4) ? leftType : GLSLX.Type.ERROR;\n        break;\n      }\n\n      case GLSLX.NodeKind.INDEX: {\n        if (rightType == GLSLX.Type.INT) {\n          var indexType = leftType.indexType();\n\n          if (indexType != null) {\n            node.resolvedType = indexType;\n          }\n\n          // Run bounds checking on the constant-folded value\n          var folded = GLSLX.Folder.fold(right);\n\n          if (folded != null && folded.kind == GLSLX.NodeKind.INT) {\n            var value = folded.asInt();\n            var count = leftType.indexCount();\n\n            // Negative indices are always invalid even if the array size is unknown\n            if (value < 0 || count != 0 && value >= count) {\n              this._log.semanticErrorOutOfBoundsIndex(right.range, value, leftType);\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // If we get here, show an error about an invalid operator\n    if (node.resolvedType == GLSLX.Type.ERROR && leftType != GLSLX.Type.ERROR && rightType != GLSLX.Type.ERROR) {\n      if (node.kind == GLSLX.NodeKind.INDEX) {\n        this._log.semanticErrorBadIndex(node.internalRange, leftType, rightType);\n      }\n\n      else {\n        this._log.semanticErrorBadBinaryOperator(node.internalRange, node.internalRange.toString(), leftType, rightType);\n      }\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveCall = function(node) {\n    var callTarget = node.callTarget();\n    this.resolveNode(callTarget);\n    var type = callTarget.resolvedType;\n    var symbol = type.symbol;\n    var $arguments = [];\n    var hasError = false;\n\n    for (var child = callTarget.nextSibling(); child != null; child = child.nextSibling()) {\n      this._resolveAsExpression(child);\n      $arguments.push(child);\n\n      if (child.resolvedType == GLSLX.Type.ERROR) {\n        hasError = true;\n      }\n    }\n\n    if (hasError) {\n      return;\n    }\n\n    if (symbol != null) {\n      if (symbol.isFunction()) {\n        this._resolveFunctionOverloads(symbol.asFunction(), node, $arguments);\n        return;\n      }\n\n      if (symbol.isStruct()) {\n        this._resolveConstructor(type, node, $arguments);\n        return;\n      }\n    }\n\n    if (type != GLSLX.Type.ERROR) {\n      this._log.semanticErrorBadCall(callTarget.range, type);\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveDot = function(node) {\n    var dotTarget = node.dotTarget();\n    var name = node.asString();\n    var range = node.internalRange;\n    this._resolveAsExpression(dotTarget);\n    var type = dotTarget.resolvedType;\n    var isAssignTarget = node.isAssignTarget();\n\n    switch (type) {\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.BVEC4:\n      case GLSLX.Type.IVEC4:\n      case GLSLX.Type.VEC4: {\n        node.resolvedType = this._validateSwizzle(range, type, name, isAssignTarget);\n        break;\n      }\n\n      default: {\n        if (type.symbol != null && type.symbol.isStruct()) {\n          for (var i = 0, list = type.symbol.asStruct().variables, count = list.length; i < count; i = i + 1 | 0) {\n            var variable = in_List.get(list, i);\n\n            if (variable.name == name) {\n              node.symbol = variable;\n              this.resolveNode(variable.type);\n              node.resolvedType = variable.type.resolvedType;\n              break;\n            }\n          }\n        }\n\n        if (node.symbol == null) {\n          this._log.semanticErrorBadMember(range, type, name);\n        }\n        break;\n      }\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveFunctionOverloads = function(overloaded, node, $arguments) {\n    var overloads = [];\n\n    // Collect all relevant overloads but ignore forward-declared functions that also have an implementation\n    for (var overload = overloaded; overload != null; overload = overload.previousOverload) {\n      if (!(overloads.indexOf(overload.sibling) != -1)) {\n        overloads.push(overload);\n      }\n    }\n\n    // Narrow down by argument count\n    if (overloads.length != 1) {\n      overloads = overloads.slice();\n      in_List.removeIf(overloads, function(overload) {\n        return overload.$arguments.length != $arguments.length;\n      });\n\n      // Narrow down by argument types\n      if (overloads.length != 1) {\n        var overloadsBeforeTypeFilter = overloads.slice();\n        in_List.removeIf(overloads, function(overload) {\n          for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\n            if (in_List.get(overload.$arguments, i).type.resolvedType != in_List.get($arguments, i).resolvedType) {\n              return true;\n            }\n          }\n\n          return false;\n        });\n\n        // Narrow down by argument types with \"conversions\" to get better error messages\n        if (overloads.length != 1) {\n          overloads = overloadsBeforeTypeFilter;\n          in_List.removeIf(overloads, function(overload) {\n            for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\n              var from = in_List.get(overload.$arguments, i).type.resolvedType;\n              var to = in_List.get($arguments, i).resolvedType;\n              var fromSize = from.componentCount();\n              var toSize = to.componentCount();\n\n              if (from != to && (fromSize == 0 || toSize == 0 || fromSize != toSize)) {\n                return true;\n              }\n            }\n\n            return false;\n          });\n        }\n      }\n    }\n\n    // Match failure\n    if (overloads.length != 1) {\n      this._log.semanticErrorBadOverloadMatch(node.callTarget().range, overloaded.name);\n      return;\n    }\n\n    // Match success\n    var overload1 = in_List.first(overloads);\n\n    if (overload1.$arguments.length != $arguments.length) {\n      this._log.semanticErrorArgumentCountFunction(node.internalRange, overload1.$arguments.length, $arguments.length, overload1.name, overload1.range);\n    }\n\n    else {\n      for (var i = 0, count = $arguments.length; i < count; i = i + 1 | 0) {\n        this.checkConversion(in_List.get($arguments, i), in_List.get(overload1.$arguments, i).type.resolvedType);\n      }\n    }\n\n    node.callTarget().symbol = overload1;\n    node.resolvedType = overload1.returnType.resolvedType;\n  };\n\n  GLSLX.Resolver.prototype._resolveConstructor = function(type, node, $arguments) {\n    node.resolvedType = type;\n\n    if (type == GLSLX.Type.ERROR) {\n      return;\n    }\n\n    if (type.componentType() != null) {\n      var count = type.componentCount();\n      var hasMatrixArgument = false;\n\n      // Visit each argument and make sure it's useful toward construction\n      var providedCount = 0;\n\n      for (var i1 = 0, list = $arguments, count1 = list.length; i1 < count1; i1 = i1 + 1 | 0) {\n        var argument = in_List.get(list, i1);\n        var argumentType = argument.resolvedType;\n        var deltaCount = argumentType.componentCount();\n\n        // Each type in a component-based types must be able to itself be unpacked into components\n        if (argumentType.componentType() == null) {\n          if (argumentType != GLSLX.Type.ERROR) {\n            this._log.semanticErrorBadConstructorValue(argument.range, argumentType, type);\n          }\n\n          return;\n        }\n\n        // Passing extra values to a constructor is allowed sometimes\n        //\n        // Allowed:\n        //\n        //   vec3(vec4(1.0));\n        //   vec3(1.0, vec4(1.0));\n        //\n        // Not allowed:\n        //\n        //   vec3(vec4(1.0), 1.0);\n        //   vec3(vec3(1.0), vec3(1.0));\n        //\n        if (providedCount >= count) {\n          this._log.semanticErrorExtraConstructorValue(argument.range, type, count, providedCount + deltaCount | 0);\n        }\n\n        if (argumentType.isMatrix()) {\n          hasMatrixArgument = true;\n        }\n\n        providedCount = providedCount + deltaCount | 0;\n      }\n\n      // If a matrix argument is given to a matrix constructor, it is an error\n      // to have any other arguments\n      var isMatrixMatrixConstructor = type.isMatrix() && hasMatrixArgument;\n\n      if (isMatrixMatrixConstructor && $arguments.length != 1) {\n        this._log.semanticErrorBadMatrixConstructor(node.internalRange);\n      }\n\n      // Validate the count (constructing a matrix using a matrix should always work)\n      else if (providedCount < count && providedCount != 1 && !isMatrixMatrixConstructor) {\n        this._log.semanticErrorBadConstructorCount(node.internalRange, type, providedCount);\n      }\n\n      return;\n    }\n\n    var symbol = type.symbol.asStruct();\n    var variables = symbol.variables;\n    var variableCount = variables.length;\n    var argumentCount = $arguments.length;\n\n    // Validate argument count\n    if (variableCount != argumentCount) {\n      this._log.semanticErrorArgumentCountConstructor(node.internalRange, variableCount, argumentCount, symbol.name, symbol.range);\n      return;\n    }\n\n    // Validate argument types\n    for (var i = 0, count2 = variableCount; i < count2; i = i + 1 | 0) {\n      this.checkConversion(in_List.get($arguments, i), in_List.get(variables, i).type.resolvedType);\n    }\n  };\n\n  GLSLX.Resolver.prototype._validateSwizzle = function(range, type, name, isAssignTarget) {\n    var count = name.length;\n\n    if (count > 4) {\n      this._log.semanticErrorBadSwizzle(range, type, name);\n      return GLSLX.Type.ERROR;\n    }\n\n    var componentCount = type.componentCount();\n\n    for (var i1 = 0, list = GLSLX.Swizzle.strings(componentCount), count2 = list.length; i1 < count2; i1 = i1 + 1 | 0) {\n      var set = in_List.get(list, i1);\n\n      if (set.indexOf(in_string.get(name, 0)) != -1) {\n        for (var i = 1, count1 = count; i < count1; i = i + 1 | 0) {\n          if (!(set.indexOf(in_string.get(name, i)) != -1)) {\n            this._log.semanticErrorBadSwizzle(range, type, name);\n            return GLSLX.Type.ERROR;\n          }\n\n          if (isAssignTarget && in_string.slice2(name, 0, i).indexOf(in_string.get(name, i)) != -1) {\n            this._log.semanticErrorBadSwizzleAssignment(range.slice(i, i + 1 | 0), in_string.get(name, i));\n            return GLSLX.Type.ERROR;\n          }\n        }\n\n        return GLSLX.Swizzle.type(type.componentType(), count);\n      }\n    }\n\n    this._log.semanticErrorBadSwizzle(range, type, name);\n    return GLSLX.Type.ERROR;\n  };\n\n  GLSLX.Resolver.prototype._resolveAsExpression = function(node) {\n    this.resolveNode(node);\n\n    if (node.kind == GLSLX.NodeKind.TYPE && node.resolvedType != GLSLX.Type.ERROR) {\n      this._log.semanticErrorUnexpectedType(node.range, node.resolvedType);\n      node.resolvedType = GLSLX.Type.ERROR;\n    }\n  };\n\n  GLSLX.Resolver.prototype._resolveChildren = function(node) {\n    for (var child = node.firstChild(); child != null; child = child.nextSibling()) {\n      this.resolveNode(child);\n    }\n  };\n\n  GLSLX.Resolver.prototype._checkStorage = function(node) {\n    var n = node;\n    assert(GLSLX.in_NodeKind.isExpression(node.kind));\n\n    label: while (true) {\n      if (n.resolvedType == GLSLX.Type.ERROR) {\n        break;\n      }\n\n      switch (n.kind) {\n        case GLSLX.NodeKind.NAME: {\n          if (n.symbol.isConst()) {\n            this._log.semanticErrorBadStorage(node.range);\n          }\n\n          break label;\n        }\n\n        case GLSLX.NodeKind.DOT: {\n          n = n.dotTarget();\n          break;\n        }\n\n        case GLSLX.NodeKind.INDEX: {\n          n = n.binaryLeft();\n          break;\n        }\n\n        default: {\n          this._log.semanticErrorBadStorage(node.range);\n          break label;\n        }\n      }\n    }\n  };\n\n  GLSLX.Resolver.prototype.checkConversion = function(node, type) {\n    if (node.resolvedType != type && node.resolvedType != GLSLX.Type.ERROR && type != GLSLX.Type.ERROR) {\n      this._log.semanticErrorBadConversion(node.range, node.resolvedType, type);\n      node.resolvedType = GLSLX.Type.ERROR;\n    }\n  };\n\n  GLSLX.ScopeKind = {\n    FUNCTION: 0,\n    GLOBAL: 1,\n    LOCAL: 2,\n    LOOP: 3,\n    STRUCT: 4\n  };\n\n  GLSLX.Scope = function(kind, parent) {\n    this.kind = kind;\n    this.parent = parent;\n    this.symbols = Object.create(null);\n  };\n\n  GLSLX.Scope.prototype.define = function(symbol) {\n    assert(!(symbol.name in this.symbols));\n    this.symbols[symbol.name] = symbol;\n  };\n\n  GLSLX.Scope.prototype.redefine = function(symbol) {\n    assert(symbol.name in this.symbols);\n    assert(in_StringMap.get1(this.symbols, symbol.name) != symbol);\n    this.symbols[symbol.name] = symbol;\n  };\n\n  GLSLX.Scope.prototype.find = function(name) {\n    var symbol = in_StringMap.get(this.symbols, name, null);\n\n    if (symbol != null) {\n      return symbol;\n    }\n\n    if (this.parent != null) {\n      return this.parent.find(name);\n    }\n\n    return null;\n  };\n\n  GLSLX.LineColumn = function(line, column) {\n    this.line = line;\n    this.column = column;\n  };\n\n  GLSLX.Source = function(name, contents) {\n    this.name = name;\n    this.contents = contents;\n    this.tokens = null;\n    this._lineOffsets = null;\n  };\n\n  GLSLX.Source.prototype.indexToLineColumn = function(index) {\n    this._computeLineOffsets();\n\n    // Binary search to find the line\n    var count = this._lineOffsets.length;\n    var line = 0;\n\n    while (count > 0) {\n      var step = count / 2 | 0;\n      var i = line + step | 0;\n\n      if (in_List.get(this._lineOffsets, i) <= index) {\n        line = i + 1 | 0;\n        count = (count - step | 0) - 1 | 0;\n      }\n\n      else {\n        count = step;\n      }\n    }\n\n    // Use the line to compute the column\n    var column = line > 0 ? index - in_List.get(this._lineOffsets, line - 1 | 0) | 0 : index;\n    return new GLSLX.LineColumn(line - 1 | 0, column);\n  };\n\n  GLSLX.Source.prototype._computeLineOffsets = function() {\n    if (this._lineOffsets == null) {\n      this._lineOffsets = [0];\n\n      for (var i = 0, count = this.contents.length; i < count; i = i + 1 | 0) {\n        if (in_string.get1(this.contents, i) == 10) {\n          this._lineOffsets.push(i + 1 | 0);\n        }\n      }\n    }\n  };\n\n  GLSLX.Swizzle = {};\n\n  GLSLX.Swizzle.strings = function(componentCount) {\n    switch (componentCount) {\n      case 2: {\n        return GLSLX.Swizzle._STRINGS_2;\n      }\n\n      case 3: {\n        return GLSLX.Swizzle._STRINGS_3;\n      }\n\n      case 4: {\n        return GLSLX.Swizzle._STRINGS_4;\n      }\n    }\n\n    assert(false);\n    return null;\n  };\n\n  GLSLX.Swizzle.type = function(comonentType, componentCount) {\n    switch (comonentType) {\n      case GLSLX.Type.BOOL: {\n        switch (componentCount) {\n          case 1: {\n            return GLSLX.Type.BOOL;\n          }\n\n          case 2: {\n            return GLSLX.Type.BVEC2;\n          }\n\n          case 3: {\n            return GLSLX.Type.BVEC3;\n          }\n\n          case 4: {\n            return GLSLX.Type.BVEC4;\n          }\n        }\n        break;\n      }\n\n      case GLSLX.Type.FLOAT: {\n        switch (componentCount) {\n          case 1: {\n            return GLSLX.Type.FLOAT;\n          }\n\n          case 2: {\n            return GLSLX.Type.VEC2;\n          }\n\n          case 3: {\n            return GLSLX.Type.VEC3;\n          }\n\n          case 4: {\n            return GLSLX.Type.VEC4;\n          }\n        }\n        break;\n      }\n\n      case GLSLX.Type.INT: {\n        switch (componentCount) {\n          case 1: {\n            return GLSLX.Type.INT;\n          }\n\n          case 2: {\n            return GLSLX.Type.IVEC2;\n          }\n\n          case 3: {\n            return GLSLX.Type.IVEC3;\n          }\n\n          case 4: {\n            return GLSLX.Type.IVEC4;\n          }\n        }\n        break;\n      }\n    }\n\n    assert(false);\n    return null;\n  };\n\n  GLSLX.SymbolFlags = {\n    // Keyword modifiers\n    ATTRIBUTE: 1,\n    CONST: 2,\n    HIGHP: 4,\n    IN: 8,\n    INOUT: 16,\n    LOWP: 32,\n    MEDIUMP: 64,\n    OUT: 128,\n    UNIFORM: 256,\n    VARYING: 512,\n\n    // Internal compiler flags\n    EXPORTED: 1024,\n    IMPORTED: 2048\n  };\n\n  GLSLX.Symbol = function(id, range, name, scope) {\n    this.id = id;\n    this.range = range;\n    this.name = name;\n    this.scope = scope;\n    this.flags = 0;\n    this.constantValue = null;\n    this.requiredExtension = null;\n    this._resolvedType = null;\n  };\n\n  GLSLX.Symbol.prototype.isConst = function() {\n    return (GLSLX.SymbolFlags.CONST & this.flags) != 0;\n  };\n\n  GLSLX.Symbol.prototype.isStruct = function() {\n    return this instanceof GLSLX.StructSymbol;\n  };\n\n  GLSLX.Symbol.prototype.isFunction = function() {\n    return this instanceof GLSLX.FunctionSymbol;\n  };\n\n  GLSLX.Symbol.prototype.isVariable = function() {\n    return this instanceof GLSLX.VariableSymbol;\n  };\n\n  GLSLX.Symbol.prototype.asStruct = function() {\n    assert(this.isStruct());\n    return this;\n  };\n\n  GLSLX.Symbol.prototype.asFunction = function() {\n    assert(this.isFunction());\n    return this;\n  };\n\n  GLSLX.Symbol.prototype.asVariable = function() {\n    assert(this.isVariable());\n    return this;\n  };\n\n  GLSLX.Symbol.prototype.resolvedType = function() {\n    if (this._resolvedType == null) {\n      this._resolvedType = new GLSLX.Type(this, null, 0);\n    }\n\n    return this._resolvedType;\n  };\n\n  GLSLX.StructSymbol = function(id, range, name, scope) {\n    GLSLX.Symbol.call(this, id, range, name, scope);\n    this.variables = [];\n  };\n\n  __extends(GLSLX.StructSymbol, GLSLX.Symbol);\n\n  GLSLX.FunctionSymbol = function(id, range, name, scope) {\n    GLSLX.Symbol.call(this, id, range, name, scope);\n    this.$arguments = [];\n    this.returnType = null;\n    this.block = null;\n    this.previousOverload = null;\n    this.sibling = null;\n  };\n\n  __extends(GLSLX.FunctionSymbol, GLSLX.Symbol);\n\n  GLSLX.FunctionSymbol.prototype.hasSameArgumentTypesAs = function($function) {\n    if (this.$arguments.length != $function.$arguments.length) {\n      return false;\n    }\n\n    for (var i = 0, count = this.$arguments.length; i < count; i = i + 1 | 0) {\n      if (in_List.get(this.$arguments, i).type.resolvedType != in_List.get($function.$arguments, i).type.resolvedType) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  GLSLX.VariableKind = {\n    ARGUMENT: 0,\n    GLOBAL: 1,\n    LOCAL: 2,\n    STRUCT: 3\n  };\n\n  GLSLX.VariableSymbol = function(id, range, name, scope, kind) {\n    GLSLX.Symbol.call(this, id, range, name, scope);\n    this.kind = kind;\n    this.type = null;\n    this.value = null;\n    this.arrayCount = null;\n  };\n\n  __extends(GLSLX.VariableSymbol, GLSLX.Symbol);\n\n  GLSLX.TokenKind = {\n    // Standard keywords\n    ATTRIBUTE: 0,\n    BOOL: 1,\n    BREAK: 2,\n    BVEC2: 3,\n    BVEC3: 4,\n    BVEC4: 5,\n    CONST: 6,\n    CONTINUE: 7,\n    DISCARD: 8,\n    DO: 9,\n    ELSE: 10,\n    FALSE: 11,\n    FLOAT: 12,\n    FOR: 13,\n    HIGHP: 14,\n    IF: 15,\n    IN: 16,\n    INOUT: 17,\n    INT: 18,\n    INVARIANT: 19,\n    IVEC2: 20,\n    IVEC3: 21,\n    IVEC4: 22,\n    LOWP: 23,\n    MAT2: 24,\n    MAT3: 25,\n    MAT4: 26,\n    MEDIUMP: 27,\n    OUT: 28,\n    PRECISION: 29,\n    RETURN: 30,\n    SAMPLER2D: 31,\n    SAMPLERCUBE: 32,\n    STRUCT: 33,\n    TRUE: 34,\n    UNIFORM: 35,\n    VARYING: 36,\n    VEC2: 37,\n    VEC3: 38,\n    VEC4: 39,\n    VOID: 40,\n    WHILE: 41,\n\n    // Non-standard keywords\n    EXPORT: 42,\n    IMPORT: 43,\n\n    // Unary\n    COMPLEMENT: 44,\n    DECREMENT: 45,\n    INCREMENT: 46,\n    NOT: 47,\n\n    // Binary\n    BITWISE_AND: 48,\n    BITWISE_OR: 49,\n    BITWISE_XOR: 50,\n    DIVIDE: 51,\n    EQUAL: 52,\n    GREATER_THAN: 53,\n    GREATER_THAN_OR_EQUAL: 54,\n    LESS_THAN: 55,\n    LESS_THAN_OR_EQUAL: 56,\n    LOGICAL_AND: 57,\n    LOGICAL_OR: 58,\n    LOGICAL_XOR: 59,\n    MINUS: 60,\n    MULTIPLY: 61,\n    NOT_EQUAL: 62,\n    PLUS: 63,\n    REMAINDER: 64,\n    SHIFT_LEFT: 65,\n    SHIFT_RIGHT: 66,\n\n    // Binary assignment\n    ASSIGN: 67,\n    ASSIGN_ADD: 68,\n    ASSIGN_BITWISE_AND: 69,\n    ASSIGN_BITWISE_OR: 70,\n    ASSIGN_BITWISE_XOR: 71,\n    ASSIGN_DIVIDE: 72,\n    ASSIGN_MULTIPLY: 73,\n    ASSIGN_REMAINDER: 74,\n    ASSIGN_SHIFT_LEFT: 75,\n    ASSIGN_SHIFT_RIGHT: 76,\n    ASSIGN_SUBTRACT: 77,\n\n    // Other operators\n    COLON: 78,\n    COMMA: 79,\n    DOT: 80,\n    LEFT_BRACE: 81,\n    LEFT_BRACKET: 82,\n    LEFT_PARENTHESIS: 83,\n    QUESTION: 84,\n    RIGHT_BRACE: 85,\n    RIGHT_BRACKET: 86,\n    RIGHT_PARENTHESIS: 87,\n    SEMICOLON: 88,\n\n    // Pragmas\n    EXTENSION: 89,\n    VERSION: 90,\n    INCLUDE: 91,\n\n    // Literals\n    FLOAT_LITERAL: 92,\n    IDENTIFIER: 93,\n    INT_LITERAL: 94,\n    STRING_LITERAL: 95,\n\n    // This is always at the end of the token stream\n    END_OF_FILE: 96\n  };\n\n  GLSLX.Token = function(range, kind) {\n    this.range = range;\n    this.kind = kind;\n  };\n\n  GLSLX.Tokenizer = {};\n\n  GLSLX.Tokenizer.tokenize = function(log, source) {\n    var parts = source.contents.split(GLSLX.Tokenizer._tokenRegex);\n    var tokens = [];\n    var start = 0;\n\n    for (var i = 0, count1 = parts.length; i < count1; i = i + 1 | 0) {\n      var part = in_List.get(parts, i);\n      var count = part.length;\n      var end = start + count | 0;\n      var range = new GLSLX.Range(source, start, end);\n\n      if (i % 2 != 0) {\n        var c = in_string.get1(part, 0);\n\n        // Identifier\n        if (c >= 65 && c <= 90 || c >= 97 && c <= 122 || c == 95) {\n          var keyword = in_StringMap.get(GLSLX.Tokenizer.keywords, part, GLSLX.TokenKind.END_OF_FILE);\n\n          if (keyword != GLSLX.TokenKind.END_OF_FILE) {\n            tokens.push(new GLSLX.Token(range, keyword));\n          }\n\n          else if (part in GLSLX.Tokenizer.reservedWords) {\n            log.syntaxErrorReservedWord(range);\n          }\n\n          else {\n            tokens.push(new GLSLX.Token(range, GLSLX.TokenKind.IDENTIFIER));\n          }\n        }\n\n        // Number\n        else if (c >= 48 && c <= 57 || c == 46 && count > 1) {\n          tokens.push(new GLSLX.Token(range, GLSLX.Tokenizer._intRegex.test(part) ? GLSLX.TokenKind.INT_LITERAL : GLSLX.TokenKind.FLOAT_LITERAL));\n        }\n\n        // Pragma\n        else if (c == 35) {\n          tokens.push(new GLSLX.Token(range, in_string.get1(part, 1) == 118 ? GLSLX.TokenKind.VERSION : in_string.get1(part, 1) == 101 ? GLSLX.TokenKind.EXTENSION : GLSLX.TokenKind.INCLUDE));\n        }\n\n        // String literal\n        else if (c == 34) {\n          tokens.push(new GLSLX.Token(range, GLSLX.TokenKind.STRING_LITERAL));\n        }\n\n        // Operator\n        else {\n          var kind = in_StringMap.get(GLSLX.Tokenizer.operators, part, GLSLX.TokenKind.END_OF_FILE);\n\n          if (kind != GLSLX.TokenKind.END_OF_FILE) {\n            tokens.push(new GLSLX.Token(range, kind));\n          }\n        }\n      }\n\n      else if (part != '') {\n        log.syntaxErrorExtraData(range, part);\n        break;\n      }\n\n      start = end;\n    }\n\n    tokens.push(new GLSLX.Token(new GLSLX.Range(source, start, start), GLSLX.TokenKind.END_OF_FILE));\n    return tokens;\n  };\n\n  GLSLX.Type = function(symbol, isArrayOf, arrayCount) {\n    this.symbol = symbol;\n    this.isArrayOf = isArrayOf;\n    this.arrayCount = arrayCount;\n    this.containsArray = false;\n    this.containsSampler = false;\n    this._arrayTypes = null;\n  };\n\n  // A count of \"0\" means an array with an unknown size\n  GLSLX.Type.prototype.arrayType = function(count) {\n    assert(count >= 0);\n\n    if (this._arrayTypes == null) {\n      this._arrayTypes = {};\n    }\n\n    var arrayType = in_IntMap.get(this._arrayTypes, count, null);\n\n    if (arrayType == null) {\n      this._arrayTypes[count] = arrayType = new GLSLX.Type(null, this, count);\n      arrayType.containsArray = true;\n      arrayType.containsSampler = this.containsSampler;\n    }\n\n    return arrayType;\n  };\n\n  GLSLX.Type.prototype.toString = function() {\n    if (this.isArrayOf != null) {\n      return this.arrayCount != 0 ? this.isArrayOf.toString() + '[' + this.arrayCount.toString() + ']' : this.isArrayOf.toString() + '[]';\n    }\n\n    return this.symbol.name;\n  };\n\n  // For index expressions where \"0 <= index < indexCount\" (so indexCount == 0 means this type is un-indexable)\n  GLSLX.Type.prototype.indexCount = function() {\n    switch (this) {\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.MAT2: {\n        return 2;\n      }\n\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.MAT3: {\n        return 3;\n      }\n\n      case GLSLX.Type.BVEC4:\n      case GLSLX.Type.VEC4:\n      case GLSLX.Type.IVEC4:\n      case GLSLX.Type.MAT4: {\n        return 4;\n      }\n\n      default: {\n        return this.arrayCount;\n      }\n    }\n  };\n\n  // For index expressions\n  GLSLX.Type.prototype.indexType = function() {\n    switch (this) {\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.BVEC4: {\n        return GLSLX.Type.BOOL;\n      }\n\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.VEC4: {\n        return GLSLX.Type.FLOAT;\n      }\n\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.IVEC4: {\n        return GLSLX.Type.INT;\n      }\n\n      case GLSLX.Type.MAT2: {\n        return GLSLX.Type.VEC2;\n      }\n\n      case GLSLX.Type.MAT3: {\n        return GLSLX.Type.VEC3;\n      }\n\n      case GLSLX.Type.MAT4: {\n        return GLSLX.Type.VEC4;\n      }\n\n      default: {\n        return this.isArrayOf;\n      }\n    }\n  };\n\n  // For constructor expressions, returns the number of required elements\n  GLSLX.Type.prototype.componentCount = function() {\n    switch (this) {\n      case GLSLX.Type.BOOL:\n      case GLSLX.Type.FLOAT:\n      case GLSLX.Type.INT: {\n        return 1;\n      }\n\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.IVEC2: {\n        return 2;\n      }\n\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.IVEC3: {\n        return 3;\n      }\n\n      case GLSLX.Type.BVEC4:\n      case GLSLX.Type.VEC4:\n      case GLSLX.Type.IVEC4:\n      case GLSLX.Type.MAT2: {\n        return 4;\n      }\n\n      case GLSLX.Type.MAT3: {\n        return 9;\n      }\n\n      case GLSLX.Type.MAT4: {\n        return 16;\n      }\n\n      default: {\n        return 0;\n      }\n    }\n  };\n\n  // For constructor expressions, returns the base element type corresponding to componentCount\n  GLSLX.Type.prototype.componentType = function() {\n    switch (this) {\n      case GLSLX.Type.BOOL:\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.BVEC4: {\n        return GLSLX.Type.BOOL;\n      }\n\n      case GLSLX.Type.FLOAT:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.VEC4:\n      case GLSLX.Type.MAT2:\n      case GLSLX.Type.MAT3:\n      case GLSLX.Type.MAT4: {\n        return GLSLX.Type.FLOAT;\n      }\n\n      case GLSLX.Type.INT:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.IVEC4: {\n        return GLSLX.Type.INT;\n      }\n\n      default: {\n        return null;\n      }\n    }\n  };\n\n  // Vector types are the only ones with swizzles\n  GLSLX.Type.prototype.isVector = function() {\n    switch (this) {\n      case GLSLX.Type.BVEC2:\n      case GLSLX.Type.BVEC3:\n      case GLSLX.Type.BVEC4:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.IVEC4:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.VEC4: {\n        return true;\n      }\n\n      default: {\n        return false;\n      }\n    }\n  };\n\n  GLSLX.Type.prototype.isMatrix = function() {\n    switch (this) {\n      case GLSLX.Type.MAT2:\n      case GLSLX.Type.MAT3:\n      case GLSLX.Type.MAT4: {\n        return true;\n      }\n\n      default: {\n        return false;\n      }\n    }\n  };\n\n  GLSLX.Type.prototype.hasIntComponents = function() {\n    switch (this) {\n      case GLSLX.Type.INT:\n      case GLSLX.Type.IVEC2:\n      case GLSLX.Type.IVEC3:\n      case GLSLX.Type.IVEC4: {\n        return true;\n      }\n\n      default: {\n        return false;\n      }\n    }\n  };\n\n  GLSLX.Type.prototype.hasFloatComponents = function() {\n    switch (this) {\n      case GLSLX.Type.FLOAT:\n      case GLSLX.Type.VEC2:\n      case GLSLX.Type.VEC3:\n      case GLSLX.Type.VEC4: {\n        return true;\n      }\n\n      case GLSLX.Type.MAT2:\n      case GLSLX.Type.MAT3:\n      case GLSLX.Type.MAT4: {\n        return true;\n      }\n\n      default: {\n        return false;\n      }\n    }\n  };\n\n  GLSLX.Type.prototype.isIntOrFloat = function() {\n    return this.hasIntComponents() || this.hasFloatComponents();\n  };\n\n  GLSLX.Type.prototype.canUseEqualityOperators = function() {\n    return !this.containsSampler && !this.containsArray;\n  };\n\n  GLSLX.Type.prototype._setContainsSampler = function() {\n    this.containsSampler = true;\n    return this;\n  };\n\n  GLSLX.Exports = {};\n\n  GLSLX.Exports.sourcesFromInput = function(input) {\n    if (__isString(input)) {\n      return [new GLSLX.Source('<stdin>', input)];\n    }\n\n    if (input instanceof Array) {\n      var sources = [];\n\n      for (var i = 0, count = input.length; i < count; i = i + 1 | 0) {\n        sources.push(new GLSLX.Source(input[i].name, input[i].contents));\n      }\n\n      return sources;\n    }\n\n    return [new GLSLX.Source(input.name, input.contents)];\n  };\n\n  GLSLX.Exports.main = function() {\n    var $this = (function() {\n      return this;\n    })();\n    var root = typeof exports !== 'undefined' ? exports : $this.GLSLX = {};\n\n    // API exports\n    root.check = GLSLX.Exports.check;\n  };\n\n  GLSLX.Exports.check = function(input, args) {\n    args = args || {};\n    var sources = GLSLX.Exports.sourcesFromInput(input);\n    var log = new GLSLX.Log();\n    var options = new GLSLX.CompilerOptions();\n\n    if (args.disableRewriting) {\n      options.compactSyntaxTree = false;\n    }\n\n    if (args.prettyPrint) {\n      options.removeWhitespace = false;\n    }\n\n    if (args.keepSymbols) {\n      options.trimSymbols = false;\n    }\n\n    if (args.globals) {\n      options.globals = args.globals;\n    }\n\n    var result = GLSLX.Compiler.typeCheck(log, sources, options);\n    return {'log': log, 'result': result};\n  };\n\n  GLSLX.in_NodeKind = {};\n\n  GLSLX.in_NodeKind.isStatement = function(self) {\n    return self >= GLSLX.NodeKind.BLOCK && self <= GLSLX.NodeKind.WHILE;\n  };\n\n  GLSLX.in_NodeKind.isExpression = function(self) {\n    return self >= GLSLX.NodeKind.CALL && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\n  };\n\n  GLSLX.in_NodeKind.isUnary = function(self) {\n    return self >= GLSLX.NodeKind.NEGATIVE && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\n  };\n\n  GLSLX.in_NodeKind.isUnaryPrefix = function(self) {\n    return self >= GLSLX.NodeKind.NEGATIVE && self <= GLSLX.NodeKind.PREFIX_INCREMENT;\n  };\n\n  GLSLX.in_NodeKind.isUnaryPostfix = function(self) {\n    return self >= GLSLX.NodeKind.POSTFIX_DECREMENT && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\n  };\n\n  GLSLX.in_NodeKind.isUnaryAssign = function(self) {\n    return self >= GLSLX.NodeKind.PREFIX_DECREMENT && self <= GLSLX.NodeKind.POSTFIX_INCREMENT;\n  };\n\n  GLSLX.in_NodeKind.isBinary = function(self) {\n    return self >= GLSLX.NodeKind.ADD && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\n  };\n\n  GLSLX.in_NodeKind.isBinaryAssign = function(self) {\n    return self >= GLSLX.NodeKind.ASSIGN && self <= GLSLX.NodeKind.ASSIGN_SUBTRACT;\n  };\n\n  GLSLX.in_NodeKind.isLoop = function(self) {\n    return self == GLSLX.NodeKind.DO_WHILE || self == GLSLX.NodeKind.FOR || self == GLSLX.NodeKind.WHILE;\n  };\n\n  GLSLX.in_TokenKind = {};\n  var in_string = {};\n\n  in_string.slice2 = function(self, start, end) {\n    assert(0 <= start && start <= end && end <= self.length);\n    return self.slice(start, end);\n  };\n\n  in_string.get1 = function(self, index) {\n    assert(0 <= index && index < self.length);\n    return self.charCodeAt(index);\n  };\n\n  in_string.get = function(self, index) {\n    assert(0 <= index && index < self.length);\n    return self[index];\n  };\n\n  var in_List = {};\n\n  in_List.setLast = function(self, x) {\n    return in_List.set(self, self.length - 1 | 0, x);\n  };\n\n  in_List.get = function(self, index) {\n    assert(0 <= index && index < self.length);\n    return self[index];\n  };\n\n  in_List.set = function(self, index, value) {\n    assert(0 <= index && index < self.length);\n    return self[index] = value;\n  };\n\n  in_List.first = function(self) {\n    assert(!(self.length == 0));\n    return in_List.get(self, 0);\n  };\n\n  in_List.last = function(self) {\n    assert(!(self.length == 0));\n    return in_List.get(self, self.length - 1 | 0);\n  };\n\n  in_List.removeLast = function(self) {\n    assert(!(self.length == 0));\n    self.pop();\n  };\n\n  in_List.takeLast = function(self) {\n    assert(!(self.length == 0));\n    return self.pop();\n  };\n\n  in_List.removeIf = function(self, callback) {\n    var index = 0;\n\n    // Remove elements in place\n    for (var i = 0, count1 = self.length; i < count1; i = i + 1 | 0) {\n      if (!callback(in_List.get(self, i))) {\n        if (index < i) {\n          in_List.set(self, index, in_List.get(self, i));\n        }\n\n        index = index + 1 | 0;\n      }\n    }\n\n    // Shrink the array to the correct size\n    while (index < self.length) {\n      in_List.removeLast(self);\n    }\n  };\n\n  var in_StringMap = {};\n\n  in_StringMap.get1 = function(self, key) {\n    assert(key in self);\n    return self[key];\n  };\n\n  in_StringMap.insert = function(self, key, value) {\n    self[key] = value;\n    return self;\n  };\n\n  in_StringMap.get = function(self, key, defaultValue) {\n    var value = self[key];\n\n    // Compare against undefined so the key is only hashed once for speed\n    return value !== void 0 ? value : defaultValue;\n  };\n\n  in_StringMap.values = function(self) {\n    var values = [];\n\n    for (var key in self) {\n      values.push(in_StringMap.get1(self, key));\n    }\n\n    return values;\n  };\n\n  var in_IntMap = {};\n\n  in_IntMap.get = function(self, key, defaultValue) {\n    var value = self[key];\n\n    // Compare against undefined so the key is only hashed once for speed\n    return value !== void 0 ? value : defaultValue;\n  };\n\n  var RELEASE = false;\n\n  // This is from https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n  GLSLX.API = '\\nimport {\\n  highp vec4 gl_Position; // should be written to\\n  mediump float gl_PointSize; // may be written to\\n\\n  const int gl_MaxVertexAttribs;\\n  const int gl_MaxVertexUniformVectors;\\n  const int gl_MaxVaryingVectors;\\n  const int gl_MaxVertexTextureImageUnits;\\n  const int gl_MaxCombinedTextureImageUnits;\\n  const int gl_MaxTextureImageUnits;\\n  const int gl_MaxFragmentUniformVectors;\\n  const int gl_MaxDrawBuffers;\\n\\n  const bool gl_FrontFacing;\\n  const mediump vec2 gl_PointCoord;\\n  const mediump vec4 gl_FragCoord;\\n  mediump vec4 gl_FragColor;\\n  mediump vec4 gl_FragData[gl_MaxDrawBuffers];\\n\\n  struct gl_DepthRangeParameters {\\n    float near; // n\\n    float far; // f\\n    float diff; // f - n\\n  };\\n\\n  uniform gl_DepthRangeParameters gl_DepthRange;\\n\\n  // Angle and Trigonometry Functions\\n  float acos(float x);\\n  float asin(float x);\\n  float atan(float y, float x);\\n  float atan(float y_over_x);\\n  float cos(float angle);\\n  float degrees(float radians);\\n  float radians(float degrees);\\n  float sin(float angle);\\n  float tan(float angle);\\n  vec2 acos(vec2 x);\\n  vec2 asin(vec2 x);\\n  vec2 atan(vec2 y, vec2 x);\\n  vec2 atan(vec2 y_over_x);\\n  vec2 cos(vec2 angle);\\n  vec2 degrees(vec2 radians);\\n  vec2 radians(vec2 degrees);\\n  vec2 sin(vec2 angle);\\n  vec2 tan(vec2 angle);\\n  vec3 acos(vec3 x);\\n  vec3 asin(vec3 x);\\n  vec3 atan(vec3 y, vec3 x);\\n  vec3 atan(vec3 y_over_x);\\n  vec3 cos(vec3 angle);\\n  vec3 degrees(vec3 radians);\\n  vec3 radians(vec3 degrees);\\n  vec3 sin(vec3 angle);\\n  vec3 tan(vec3 angle);\\n  vec4 acos(vec4 x);\\n  vec4 asin(vec4 x);\\n  vec4 atan(vec4 y, vec4 x);\\n  vec4 atan(vec4 y_over_x);\\n  vec4 cos(vec4 angle);\\n  vec4 sin(vec4 angle);\\n  vec4 tan(vec4 angle);\\n\\n  // Exponential Functions\\n  float exp(float x);\\n  float exp2(float x);\\n  float inversesqrt(float x);\\n  float log(float x);\\n  float log2(float x);\\n  float pow(float x, float y);\\n  float sqrt(float x);\\n  vec2 exp(vec2 x);\\n  vec2 exp2(vec2 x);\\n  vec2 inversesqrt(vec2 x);\\n  vec2 log(vec2 x);\\n  vec2 log2(vec2 x);\\n  vec2 pow(vec2 x, vec2 y);\\n  vec2 sqrt(vec2 x);\\n  vec3 exp(vec3 x);\\n  vec3 exp2(vec3 x);\\n  vec3 inversesqrt(vec3 x);\\n  vec3 log(vec3 x);\\n  vec3 log2(vec3 x);\\n  vec3 pow(vec3 x, vec3 y);\\n  vec3 sqrt(vec3 x);\\n  vec4 exp(vec4 x);\\n  vec4 exp2(vec4 x);\\n  vec4 inversesqrt(vec4 x);\\n  vec4 log(vec4 x);\\n  vec4 log2(vec4 x);\\n  vec4 pow(vec4 x, vec4 y);\\n  vec4 sqrt(vec4 x);\\n\\n  // Common Functions\\n  float abs(float x);\\n  float ceil(float x);\\n  float clamp(float x, float minVal, float maxVal);\\n  float floor(float x);\\n  float fract(float x);\\n  float max(float x, float y);\\n  float min(float x, float y);\\n  float mix(float x, float y, float a);\\n  float mod(float x, float y);\\n  float sign(float x);\\n  float smoothstep(float edge0, float edge1, float x);\\n  float step(float edge, float x);\\n  vec2 abs(vec2 x);\\n  vec2 ceil(vec2 x);\\n  vec2 clamp(vec2 x, float minVal, float maxVal);\\n  vec2 clamp(vec2 x, vec2 minVal, vec2 maxVal);\\n  vec2 floor(vec2 x);\\n  vec2 fract(vec2 x);\\n  vec2 max(vec2 x, float y);\\n  vec2 max(vec2 x, vec2 y);\\n  vec2 min(vec2 x, float y);\\n  vec2 min(vec2 x, vec2 y);\\n  vec2 mix(vec2 x, vec2 y, float a);\\n  vec2 mix(vec2 x, vec2 y, vec2 a);\\n  vec2 mod(vec2 x, float y);\\n  vec2 mod(vec2 x, vec2 y);\\n  vec2 sign(vec2 x);\\n  vec2 smoothstep(float edge0, float edge1, vec2 x);\\n  vec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x);\\n  vec2 step(float edge, vec2 x);\\n  vec2 step(vec2 edge, vec2 x);\\n  vec3 abs(vec3 x);\\n  vec3 ceil(vec3 x);\\n  vec3 clamp(vec3 x, float minVal, float maxVal);\\n  vec3 clamp(vec3 x, vec3 minVal, vec3 maxVal);\\n  vec3 floor(vec3 x);\\n  vec3 fract(vec3 x);\\n  vec3 max(vec3 x, float y);\\n  vec3 max(vec3 x, vec3 y);\\n  vec3 min(vec3 x, float y);\\n  vec3 min(vec3 x, vec3 y);\\n  vec3 mix(vec3 x, vec3 y, float a);\\n  vec3 mix(vec3 x, vec3 y, vec3 a);\\n  vec3 mod(vec3 x, float y);\\n  vec3 mod(vec3 x, vec3 y);\\n  vec3 sign(vec3 x);\\n  vec3 smoothstep(float edge0, float edge1, vec3 x);\\n  vec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x);\\n  vec3 step(float edge, vec3 x);\\n  vec3 step(vec3 edge, vec3 x);\\n  vec4 abs(vec4 x);\\n  vec4 ceil(vec4 x);\\n  vec4 clamp(vec4 x, float minVal, float maxVal);\\n  vec4 clamp(vec4 x, vec4 minVal, vec4 maxVal);\\n  vec4 floor(vec4 x);\\n  vec4 fract(vec4 x);\\n  vec4 max(vec4 x, float y);\\n  vec4 max(vec4 x, vec4 y);\\n  vec4 min(vec4 x, float y);\\n  vec4 min(vec4 x, vec4 y);\\n  vec4 mix(vec4 x, vec4 y, float a);\\n  vec4 mix(vec4 x, vec4 y, vec4 a);\\n  vec4 mod(vec4 x, float y);\\n  vec4 mod(vec4 x, vec4 y);\\n  vec4 sign(vec4 x);\\n  vec4 smoothstep(float edge0, float edge1, vec4 x);\\n  vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x);\\n  vec4 step(float edge, vec4 x);\\n  vec4 step(vec4 edge, vec4 x);\\n\\n  // Geometric Functions\\n  float distance(float p0, float p1);\\n  float distance(vec2 p0, vec2 p1);\\n  float distance(vec3 p0, vec3 p1);\\n  float distance(vec4 p0, vec4 p1);\\n  float dot(float x, float y);\\n  float dot(vec2 x, vec2 y);\\n  float dot(vec3 x, vec3 y);\\n  float dot(vec4 x, vec4 y);\\n  float faceforward(float N, float I, float Nref);\\n  float length(float x);\\n  float length(vec2 x);\\n  float length(vec3 x);\\n  float length(vec4 x);\\n  float normalize(float x);\\n  float reflect(float I, float N);\\n  float refract(float I, float N, float eta);\\n  vec2 faceforward(vec2 N, vec2 I, vec2 Nref);\\n  vec2 normalize(vec2 x);\\n  vec2 reflect(vec2 I, vec2 N);\\n  vec2 refract(vec2 I, vec2 N, float eta);\\n  vec3 cross(vec3 x, vec3 y);\\n  vec3 faceforward(vec3 N, vec3 I, vec3 Nref);\\n  vec3 normalize(vec3 x);\\n  vec3 reflect(vec3 I, vec3 N);\\n  vec3 refract(vec3 I, vec3 N, float eta);\\n  vec4 faceforward(vec4 N, vec4 I, vec4 Nref);\\n  vec4 normalize(vec4 x);\\n  vec4 reflect(vec4 I, vec4 N);\\n  vec4 refract(vec4 I, vec4 N, float eta);\\n\\n  // Matrix Functions\\n  mat2 matrixCompMult(mat2 x, mat2 y);\\n  mat3 matrixCompMult(mat3 x, mat3 y);\\n  mat4 matrixCompMult(mat4 x, mat4 y);\\n\\n  // Vector Relational Functions\\n  bool all(bvec2 x);\\n  bool all(bvec3 x);\\n  bool all(bvec4 x);\\n  bool any(bvec2 x);\\n  bool any(bvec3 x);\\n  bool any(bvec4 x);\\n  bvec2 equal(bvec2 x, bvec2 y);\\n  bvec2 equal(ivec2 x, ivec2 y);\\n  bvec2 equal(vec2 x, vec2 y);\\n  bvec2 greaterThan(ivec2 x, ivec2 y);\\n  bvec2 greaterThan(vec2 x, vec2 y);\\n  bvec2 greaterThanEqual(ivec2 x, ivec2 y);\\n  bvec2 greaterThanEqual(vec2 x, vec2 y);\\n  bvec2 lessThan(ivec2 x, ivec2 y);\\n  bvec2 lessThan(vec2 x, vec2 y);\\n  bvec2 lessThanEqual(ivec2 x, ivec2 y);\\n  bvec2 lessThanEqual(vec2 x, vec2 y);\\n  bvec2 not(bvec2 x);\\n  bvec2 notEqual(bvec2 x, bvec2 y);\\n  bvec2 notEqual(ivec2 x, ivec2 y);\\n  bvec2 notEqual(vec2 x, vec2 y);\\n  bvec3 equal(bvec3 x, bvec3 y);\\n  bvec3 equal(ivec3 x, ivec3 y);\\n  bvec3 equal(vec3 x, vec3 y);\\n  bvec3 greaterThan(ivec3 x, ivec3 y);\\n  bvec3 greaterThan(vec3 x, vec3 y);\\n  bvec3 greaterThanEqual(ivec3 x, ivec3 y);\\n  bvec3 greaterThanEqual(vec3 x, vec3 y);\\n  bvec3 lessThan(ivec3 x, ivec3 y);\\n  bvec3 lessThan(vec3 x, vec3 y);\\n  bvec3 lessThanEqual(ivec3 x, ivec3 y);\\n  bvec3 lessThanEqual(vec3 x, vec3 y);\\n  bvec3 not(bvec3 x);\\n  bvec3 notEqual(bvec3 x, bvec3 y);\\n  bvec3 notEqual(ivec3 x, ivec3 y);\\n  bvec3 notEqual(vec3 x, vec3 y);\\n  bvec4 equal(bvec4 x, bvec4 y);\\n  bvec4 equal(ivec4 x, ivec4 y);\\n  bvec4 equal(vec4 x, vec4 y);\\n  bvec4 greaterThan(ivec4 x, ivec4 y);\\n  bvec4 greaterThan(vec4 x, vec4 y);\\n  bvec4 greaterThanEqual(ivec4 x, ivec4 y);\\n  bvec4 greaterThanEqual(vec4 x, vec4 y);\\n  bvec4 lessThan(ivec4 x, ivec4 y);\\n  bvec4 lessThan(vec4 x, vec4 y);\\n  bvec4 lessThanEqual(ivec4 x, ivec4 y);\\n  bvec4 lessThanEqual(vec4 x, vec4 y);\\n  bvec4 not(bvec4 x);\\n  bvec4 notEqual(bvec4 x, bvec4 y);\\n  bvec4 notEqual(ivec4 x, ivec4 y);\\n  bvec4 notEqual(vec4 x, vec4 y);\\n\\n  // Texture Lookup Functions\\n  vec4 texture2D(sampler2D sampler, vec2 coord);\\n  vec4 texture2D(sampler2D sampler, vec2 coord, float bias);\\n  vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);\\n  vec4 texture2DProj(sampler2D sampler, vec3 coord);\\n  vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);\\n  vec4 texture2DProj(sampler2D sampler, vec4 coord);\\n  vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);\\n  vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);\\n  vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);\\n  vec4 textureCube(samplerCube sampler, vec3 coord);\\n  vec4 textureCube(samplerCube sampler, vec3 coord, float bias);\\n  vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);\\n\\n  #extension GL_OES_standard_derivatives {\\n    float dFdx(float v);\\n    float dFdy(float v);\\n    float fwidth(float v);\\n    vec2 dFdx(vec2 v);\\n    vec2 dFdy(vec2 v);\\n    vec2 fwidth(vec2 v);\\n    vec3 dFdx(vec3 v);\\n    vec3 dFdy(vec3 v);\\n    vec3 fwidth(vec3 v);\\n    vec4 dFdx(vec4 v);\\n    vec4 dFdy(vec4 v);\\n    vec4 fwidth(vec4 v);\\n  }\\n\\n  #extension GL_EXT_frag_depth {\\n    float gl_FragDepthEXT;\\n  }\\n\\n  #extension GL_EXT_shader_texture_lod {\\n    vec4 texture2DGradEXT(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DLodEXT(sampler2D sampler, vec2 coord, float lod);\\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec3 coord, float lod);\\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec4 coord, float lod);\\n    vec4 textureCubeGradEXT(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\\n    vec4 textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod);\\n  }\\n}\\n';\n  GLSLX.Node._nextID = 0;\n  GLSLX.Parser.pratt = null;\n  GLSLX.Parser._extensionBehaviors = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'disable', GLSLX.ExtensionBehavior.DISABLE), 'enable', GLSLX.ExtensionBehavior.ENABLE), 'require', GLSLX.ExtensionBehavior.REQUIRE), 'warn', GLSLX.ExtensionBehavior.WARN);\n\n  // From https://www.khronos.org/registry/webgl/extensions/\n  GLSLX.Parser._knownWebGLExtensions = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'GL_OES_standard_derivatives', 0), 'GL_EXT_frag_depth', 0), 'GL_EXT_draw_buffers', 0), 'GL_EXT_shader_texture_lod', 0);\n  GLSLX.Swizzle._STRINGS_2 = ['xy', 'st', 'rg'];\n  GLSLX.Swizzle._STRINGS_3 = ['xyz', 'stp', 'rgb'];\n  GLSLX.Swizzle._STRINGS_4 = ['xyzw', 'stpq', 'rgba'];\n\n  // The order matters here due to greedy matching\n  GLSLX.Tokenizer._tokenRegex = new RegExp('(' + '\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + '\\\\.[0-9]+\\\\b|' + '[0-9]+\\\\.[0-9]+[eE][+-]?[0-9]+\\\\b|' + '[0-9]+\\\\.[0-9]+\\\\b|' + '[0-9]+\\\\.[eE][+-]?[0-9]+\\\\b|' + '[0-9]+\\\\.|' + '[0-9]+[eE][+-]?[0-9]+\\\\b|' + '[1-9][0-9]*\\\\b|' + '0[0-7]*\\\\b|' + '0[xX][0-9A-Fa-f]+\\\\b|' + '[ \\t\\r\\n]|' + '/\\\\*(?:.|\\r\\n|\\n)*?\\\\*/|' + '//.*|' + '&&|\\\\|\\\\||\\\\^\\\\^|\\\\+\\\\+|--|<<=?|>>=?|[()[\\\\]{}\\\\.,?:;]|[+\\\\-*/%=!<>&|^~]=?|' + '[A-Za-z_][A-Za-z0-9_]*\\\\b|' + '#(?:version|extension|include)\\\\b|' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')');\n  GLSLX.Tokenizer._intRegex = new RegExp('^(' + '[1-9][0-9]*|' + '0[0-7]*|' + '0[xX][0-9A-Fa-f]+' + ')$');\n  GLSLX.Tokenizer.keywords = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'attribute', GLSLX.TokenKind.ATTRIBUTE), 'bool', GLSLX.TokenKind.BOOL), 'break', GLSLX.TokenKind.BREAK), 'bvec2', GLSLX.TokenKind.BVEC2), 'bvec3', GLSLX.TokenKind.BVEC3), 'bvec4', GLSLX.TokenKind.BVEC4), 'const', GLSLX.TokenKind.CONST), 'continue', GLSLX.TokenKind.CONTINUE), 'discard', GLSLX.TokenKind.DISCARD), 'do', GLSLX.TokenKind.DO), 'else', GLSLX.TokenKind.ELSE), 'false', GLSLX.TokenKind.FALSE), 'float', GLSLX.TokenKind.FLOAT), 'for', GLSLX.TokenKind.FOR), 'highp', GLSLX.TokenKind.HIGHP), 'if', GLSLX.TokenKind.IF), 'in', GLSLX.TokenKind.IN), 'inout', GLSLX.TokenKind.INOUT), 'int', GLSLX.TokenKind.INT), 'invariant', GLSLX.TokenKind.INVARIANT), 'ivec2', GLSLX.TokenKind.IVEC2), 'ivec3', GLSLX.TokenKind.IVEC3), 'ivec4', GLSLX.TokenKind.IVEC4), 'lowp', GLSLX.TokenKind.LOWP), 'mat2', GLSLX.TokenKind.MAT2), 'mat3', GLSLX.TokenKind.MAT3), 'mat4', GLSLX.TokenKind.MAT4), 'mediump', GLSLX.TokenKind.MEDIUMP), 'out', GLSLX.TokenKind.OUT), 'precision', GLSLX.TokenKind.PRECISION), 'return', GLSLX.TokenKind.RETURN), 'sampler2D', GLSLX.TokenKind.SAMPLER2D), 'samplerCube', GLSLX.TokenKind.SAMPLERCUBE), 'struct', GLSLX.TokenKind.STRUCT), 'true', GLSLX.TokenKind.TRUE), 'uniform', GLSLX.TokenKind.UNIFORM), 'varying', GLSLX.TokenKind.VARYING), 'vec2', GLSLX.TokenKind.VEC2), 'vec3', GLSLX.TokenKind.VEC3), 'vec4', GLSLX.TokenKind.VEC4), 'void', GLSLX.TokenKind.VOID), 'while', GLSLX.TokenKind.WHILE), 'export', GLSLX.TokenKind.EXPORT), 'import', GLSLX.TokenKind.IMPORT);\n  GLSLX.Tokenizer.operators = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), '~', GLSLX.TokenKind.COMPLEMENT), '--', GLSLX.TokenKind.DECREMENT), '++', GLSLX.TokenKind.INCREMENT), '!', GLSLX.TokenKind.NOT), '&', GLSLX.TokenKind.BITWISE_AND), '|', GLSLX.TokenKind.BITWISE_OR), '^', GLSLX.TokenKind.BITWISE_XOR), '/', GLSLX.TokenKind.DIVIDE), '==', GLSLX.TokenKind.EQUAL), '>', GLSLX.TokenKind.GREATER_THAN), '>=', GLSLX.TokenKind.GREATER_THAN_OR_EQUAL), '<', GLSLX.TokenKind.LESS_THAN), '<=', GLSLX.TokenKind.LESS_THAN_OR_EQUAL), '&&', GLSLX.TokenKind.LOGICAL_AND), '||', GLSLX.TokenKind.LOGICAL_OR), '^^', GLSLX.TokenKind.LOGICAL_XOR), '-', GLSLX.TokenKind.MINUS), '*', GLSLX.TokenKind.MULTIPLY), '!=', GLSLX.TokenKind.NOT_EQUAL), '+', GLSLX.TokenKind.PLUS), '%', GLSLX.TokenKind.REMAINDER), '<<', GLSLX.TokenKind.SHIFT_LEFT), '>>', GLSLX.TokenKind.SHIFT_RIGHT), '=', GLSLX.TokenKind.ASSIGN), '+=', GLSLX.TokenKind.ASSIGN_ADD), '&=', GLSLX.TokenKind.ASSIGN_BITWISE_AND), '|=', GLSLX.TokenKind.ASSIGN_BITWISE_OR), '^=', GLSLX.TokenKind.ASSIGN_BITWISE_XOR), '/=', GLSLX.TokenKind.ASSIGN_DIVIDE), '*=', GLSLX.TokenKind.ASSIGN_MULTIPLY), '%=', GLSLX.TokenKind.ASSIGN_REMAINDER), '<<=', GLSLX.TokenKind.ASSIGN_SHIFT_LEFT), '>>=', GLSLX.TokenKind.ASSIGN_SHIFT_RIGHT), '-=', GLSLX.TokenKind.ASSIGN_SUBTRACT), ':', GLSLX.TokenKind.COLON), ',', GLSLX.TokenKind.COMMA), '.', GLSLX.TokenKind.DOT), '{', GLSLX.TokenKind.LEFT_BRACE), '[', GLSLX.TokenKind.LEFT_BRACKET), '(', GLSLX.TokenKind.LEFT_PARENTHESIS), '?', GLSLX.TokenKind.QUESTION), '}', GLSLX.TokenKind.RIGHT_BRACE), ']', GLSLX.TokenKind.RIGHT_BRACKET), ')', GLSLX.TokenKind.RIGHT_PARENTHESIS), ';', GLSLX.TokenKind.SEMICOLON);\n  GLSLX.Tokenizer.reservedWords = in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(in_StringMap.insert(Object.create(null), 'asm', 0), 'cast', 0), 'class', 0), 'default', 0), 'double', 0), 'dvec2', 0), 'dvec3', 0), 'dvec4', 0), 'enum', 0), 'extern', 0), 'external', 0), 'fixed', 0), 'flat', 0), 'fvec2', 0), 'fvec3', 0), 'fvec4', 0), 'goto', 0), 'half', 0), 'hvec2', 0), 'hvec3', 0), 'hvec4', 0), 'inline', 0), 'input', 0), 'interface', 0), 'long', 0), 'namespace', 0), 'noinline', 0), 'output', 0), 'packed', 0), 'public', 0), 'sampler1D', 0), 'sampler1DShadow', 0), 'sampler2DRect', 0), 'sampler2DRectShadow', 0), 'sampler2DShadow', 0), 'sampler3D', 0), 'sampler3DRect', 0), 'short', 0), 'sizeof', 0), 'static', 0), 'superp', 0), 'switch', 0), 'template', 0), 'this', 0), 'typedef', 0), 'union', 0), 'unsigned', 0), 'using', 0), 'volatile', 0);\n  GLSLX.Type.BOOL = new GLSLX.StructSymbol(-1, null, 'bool', null).resolvedType();\n  GLSLX.Type.BVEC2 = new GLSLX.StructSymbol(-2, null, 'bvec2', null).resolvedType();\n  GLSLX.Type.BVEC3 = new GLSLX.StructSymbol(-3, null, 'bvec3', null).resolvedType();\n  GLSLX.Type.BVEC4 = new GLSLX.StructSymbol(-4, null, 'bvec4', null).resolvedType();\n  GLSLX.Type.ERROR = new GLSLX.StructSymbol(-5, null, '<error>', null).resolvedType();\n  GLSLX.Type.FLOAT = new GLSLX.StructSymbol(-6, null, 'float', null).resolvedType();\n  GLSLX.Type.INT = new GLSLX.StructSymbol(-7, null, 'int', null).resolvedType();\n  GLSLX.Type.IVEC2 = new GLSLX.StructSymbol(-8, null, 'ivec2', null).resolvedType();\n  GLSLX.Type.IVEC3 = new GLSLX.StructSymbol(-9, null, 'ivec3', null).resolvedType();\n  GLSLX.Type.IVEC4 = new GLSLX.StructSymbol(-10, null, 'ivec4', null).resolvedType();\n  GLSLX.Type.MAT2 = new GLSLX.StructSymbol(-11, null, 'mat2', null).resolvedType();\n  GLSLX.Type.MAT3 = new GLSLX.StructSymbol(-12, null, 'mat3', null).resolvedType();\n  GLSLX.Type.MAT4 = new GLSLX.StructSymbol(-13, null, 'mat4', null).resolvedType();\n  GLSLX.Type.SAMPLER2D = new GLSLX.StructSymbol(-14, null, 'sampler2D', null).resolvedType()._setContainsSampler();\n  GLSLX.Type.SAMPLERCUBE = new GLSLX.StructSymbol(-15, null, 'samplerCube', null).resolvedType()._setContainsSampler();\n  GLSLX.Type.VEC2 = new GLSLX.StructSymbol(-16, null, 'vec2', null).resolvedType();\n  GLSLX.Type.VEC3 = new GLSLX.StructSymbol(-17, null, 'vec3', null).resolvedType();\n  GLSLX.Type.VEC4 = new GLSLX.StructSymbol(-18, null, 'vec4', null).resolvedType();\n  GLSLX.Type.VOID = new GLSLX.StructSymbol(-19, null, 'void', null).resolvedType();\n  GLSLX.in_TokenKind._strings = ['ATTRIBUTE', 'BOOL', 'BREAK', 'BVEC2', 'BVEC3', 'BVEC4', 'CONST', 'CONTINUE', 'DISCARD', 'DO', 'ELSE', 'FALSE', 'FLOAT', 'FOR', 'HIGHP', 'IF', 'IN', 'INOUT', 'INT', 'INVARIANT', 'IVEC2', 'IVEC3', 'IVEC4', 'LOWP', 'MAT2', 'MAT3', 'MAT4', 'MEDIUMP', 'OUT', 'PRECISION', 'RETURN', 'SAMPLER2D', 'SAMPLERCUBE', 'STRUCT', 'TRUE', 'UNIFORM', 'VARYING', 'VEC2', 'VEC3', 'VEC4', 'VOID', 'WHILE', 'EXPORT', 'IMPORT', 'COMPLEMENT', 'DECREMENT', 'INCREMENT', 'NOT', 'BITWISE_AND', 'BITWISE_OR', 'BITWISE_XOR', 'DIVIDE', 'EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'LOGICAL_AND', 'LOGICAL_OR', 'LOGICAL_XOR', 'MINUS', 'MULTIPLY', 'NOT_EQUAL', 'PLUS', 'REMAINDER', 'SHIFT_LEFT', 'SHIFT_RIGHT', 'ASSIGN', 'ASSIGN_ADD', 'ASSIGN_BITWISE_AND', 'ASSIGN_BITWISE_OR', 'ASSIGN_BITWISE_XOR', 'ASSIGN_DIVIDE', 'ASSIGN_MULTIPLY', 'ASSIGN_REMAINDER', 'ASSIGN_SHIFT_LEFT', 'ASSIGN_SHIFT_RIGHT', 'ASSIGN_SUBTRACT', 'COLON', 'COMMA', 'DOT', 'LEFT_BRACE', 'LEFT_BRACKET', 'LEFT_PARENTHESIS', 'QUESTION', 'RIGHT_BRACE', 'RIGHT_BRACKET', 'RIGHT_PARENTHESIS', 'SEMICOLON', 'EXTENSION', 'VERSION', 'INCLUDE', 'FLOAT_LITERAL', 'IDENTIFIER', 'INT_LITERAL', 'STRING_LITERAL', 'END_OF_FILE'];\n\n  GLSLX.Exports.main();\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/glsl-parser/parser.js\n// module id = TFw8\n// module chunks = 1"],"sourceRoot":""}